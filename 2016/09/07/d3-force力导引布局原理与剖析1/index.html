<!doctype html><html class="theme-next pisces use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.proxy.ustclug.org/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css"><meta name="keywords" content="d3,"><link rel="alternate" href="/atom.xml" title="Reducer" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0"><meta name="description" content="在数据可视化中，我们往往会使用图来表达数据中所蕴含的信息。而图布局算法可以使散乱的信息 (信息多以点线的关系承载) 通过一种清晰的方式呈现出来，并符合相应的美学标准。在图布局算法模型中，其建立在粒子物理理论的基础上，将节点模拟成为原子，通过原子间的引力和斥力来得到节点的速度与加速度，计算其移动方位与距离，最终达到一个稳定平衡的状态，从而完成布局。以下就是由 d3 实现的力引导布局:

在 d3 的"><meta property="og:type" content="article"><meta property="og:title" content="d3-force力导引布局原理与剖析(一)"><meta property="og:url" content="http://blackganglion.com/2016/09/07/d3-force力导引布局原理与剖析1/index.html"><meta property="og:site_name" content="Reducer"><meta property="og:description" content="在数据可视化中，我们往往会使用图来表达数据中所蕴含的信息。而图布局算法可以使散乱的信息 (信息多以点线的关系承载) 通过一种清晰的方式呈现出来，并符合相应的美学标准。在图布局算法模型中，其建立在粒子物理理论的基础上，将节点模拟成为原子，通过原子间的引力和斥力来得到节点的速度与加速度，计算其移动方位与距离，最终达到一个稳定平衡的状态，从而完成布局。以下就是由 d3 实现的力引导布局:

在 d3 的"><meta property="og:image" content="http://ol2d3d8nb.bkt.clouddn.com/24-1.png"><meta property="og:image" content="http://ol2d3d8nb.bkt.clouddn.com/24-2.png"><meta property="og:image" content="http://ol2d3d8nb.bkt.clouddn.com/24-3.png"><meta property="og:updated_time" content="2017-02-08T16:35:24.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="d3-force力导引布局原理与剖析(一)"><meta name="twitter:description" content="在数据可视化中，我们往往会使用图来表达数据中所蕴含的信息。而图布局算法可以使散乱的信息 (信息多以点线的关系承载) 通过一种清晰的方式呈现出来，并符合相应的美学标准。在图布局算法模型中，其建立在粒子物理理论的基础上，将节点模拟成为原子，通过原子间的引力和斥力来得到节点的速度与加速度，计算其移动方位与距离，最终达到一个稳定平衡的状态，从而完成布局。以下就是由 d3 实现的力引导布局:

在 d3 的"><meta name="twitter:image" content="http://ol2d3d8nb.bkt.clouddn.com/24-1.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",sidebar:{position:"right",display:"post",offset:12,offset_float:0,b2t:!1,scrollpercent:!1},fancybox:!0,motion:!0,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://blackganglion.com/2016/09/07/d3-force力导引布局原理与剖析1/"><title>d3-force力导引布局原理与剖析(一) | Reducer</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?27ecee01e57d9d4442dc1768d4dcce4a";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><div class="container sidebar-position-right page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Reducer</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Where there is a will, there is a way.</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://blackganglion.com/2016/09/07/d3-force力导引布局原理与剖析1/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="淡苍"><meta itemprop="description" content=""><meta itemprop="image" content="http://ol2d3d8nb.bkt.clouddn.com/fly.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Reducer"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">d3-force力导引布局原理与剖析(一)</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-09-07T00:22:06+08:00">2016-09-07</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据可视化/" itemprop="url" rel="index"><span itemprop="name">数据可视化</span></a></span></span> <span class="post-comments-count"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i></span><a class="cloud-tie-join-count" href="/2016/09/07/d3-force力导引布局原理与剖析1/#comments" itemprop="discussionUrl"><span class="post-comments-count join-count" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><p>在数据可视化中，我们往往会使用图来表达数据中所蕴含的信息。而图布局算法可以使散乱的信息 (信息多以点线的关系承载) 通过一种清晰的方式呈现出来，并符合相应的美学标准。在图布局算法模型中，其建立在粒子物理理论的基础上，将节点模拟成为原子，通过原子间的引力和斥力来得到节点的速度与加速度，计算其移动方位与距离，最终达到一个稳定平衡的状态，从而完成布局。以下就是由 d3 实现的力引导布局:</p><p><img src="http://ol2d3d8nb.bkt.clouddn.com/24-1.png" alt="d3-force"></p><p>在 d3 的实现中，为了达到性能与效果的平衡，节点与节点间模拟同种电荷相互排斥，并将节点存入四叉树中，利用 Barnes–Hut 近似来减少节点间电荷斥力的计算量。同时连线间的节点模拟弹簧牵引力，节点的速度综合斥力引力得出，并发生阻尼衰减，最终达到整图平衡。</p><p>在本文中，我们将对 d3 实现的力导引布局进行一步步分解，详细剖析其实现过程与背后的原理。在此之前，读者们自行阅读上图实现<a href="http://bl.ocks.org/mbostock/4062045" target="_blank" rel="external">源码</a>，熟悉一下 <a href="https://github.com/d3/d3-force" target="_blank" rel="external">d3-force</a> API。</p><a id="more"></a><h2 id="节点的处理与优化"><a href="#节点的处理与优化" class="headerlink" title="节点的处理与优化"></a>节点的处理与优化</h2><h3 id="初始化导入节点"><a href="#初始化导入节点" class="headerlink" title="初始化导入节点"></a>初始化导入节点</h3><p>首先，需要将节点形成所符合的数据结构导入 d3 当中，对于每一个节点进行预处理，节点按一定的半径和旋转角度环绕起来，vx 与 vy 分别表示节点在 x 轴和 y 轴方向上的速度分量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> initialRadius = <span class="number">10</span>,</div><div class="line">    initialAngle = <span class="built_in">Math</span>.PI * (<span class="number">3</span> - <span class="built_in">Math</span>.sqrt(<span class="number">5</span>));</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, n = nodes.length, node; i &lt; n; ++i) &#123;</div><div class="line">  node = nodes[i], node.index = i;</div><div class="line">  ...</div><div class="line">    var radius = initialRadius * <span class="built_in">Math</span>.sqrt(i), angle = i * initialAngle;</div><div class="line">    node.x = radius * <span class="built_in">Math</span>.cos(angle);</div><div class="line">    node.y = radius * <span class="built_in">Math</span>.sin(angle);</div><div class="line">  ...</div><div class="line">    node.vx = node.vy = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="建立节点四叉树"><a href="#建立节点四叉树" class="headerlink" title="建立节点四叉树"></a>建立节点四叉树</h3><p>四叉树 (Q-Tree) 是一种树形数据结构。它的每个节点下至多可以有四个子节点，通常把一部分二维空间细分为四个象限并把该区域里的相关信息存入到四叉树节点中。四叉树的每一个节点代表一个矩形区域，每一个矩形区域又可划分为四个小矩形区域，这四个小矩形区域作为四个子节点所代表的矩形区域，正如下图的矩阵虚线划分:</p><p><img src="http://ol2d3d8nb.bkt.clouddn.com/24-2.png" alt="节点初始与四叉树划分"></p><p>遍历导入所有节点数据，求出节点最小 x 值 $x_0$ ，最大 x 值 $x_1$，最小 y 值 $y_0$，最大 y 值 $y_1$，将 $(x_0, y_0)$ 点坐标以 $2$ 倍增，使 $x_0 * 2^n \geq x_1, y_0 * 2^n \geq y_1$，那么新 $(x_1, y_1)$ 为 $(x_0 * 2^n, y_0 * 2^n)$。以 $2$ 倍增符合四叉树在一维上不断对半划分的特点。</p><p>一边添加节点，一边对四叉树进行划分，因此一般来说四叉树是不完全的。在添加时会遇到如下 4 种情况:</p><p><strong>case1:</strong> 当前四叉树为空，直接将当前节点作为树的根节点。<br><strong>case2:</strong> 当前查询节点为真实节点(对象节点)，即与添加节点所处范围矩阵一致，需要建立数组索引，即再次划分该矩阵，直到查询节点与添加节点分处不同矩阵。<br><strong>case3:</strong> 当前查询节点为索引节点(数组节点)，且添加节点所处范围矩阵为空，直接添加。<br><strong>case4:</strong> 当前查询节点为真实节点，且添加节点的坐标与其完全相等，直接下挂。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">tree, x, y, d</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> node = tree._root,</div><div class="line">      leaf = &#123;<span class="attr">data</span>: d&#125;,</div><div class="line">      x0 = tree._x0,</div><div class="line">      y0 = tree._y0,</div><div class="line">      x1 = tree._x1,</div><div class="line">      y1 = tree._y1,</div><div class="line">      ...</div><div class="line"></div><div class="line">  <span class="comment">// 当前tree._root为空，对于case1</span></div><div class="line">  <span class="comment">// If the tree is empty, initialize the root as a leaf.</span></div><div class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> tree._root = leaf, tree;</div><div class="line"></div><div class="line">  <span class="comment">// 类似与二分查找，自顶向下搜索</span></div><div class="line">  <span class="comment">// Find the existing leaf for the new point, or add it.</span></div><div class="line">  <span class="keyword">while</span> (node.length) &#123;</div><div class="line">    <span class="keyword">if</span> (right = x &gt;= (xm = (x0 + x1) / <span class="number">2</span>)) x0 = xm; <span class="keyword">else</span> x1 = xm;</div><div class="line">    <span class="keyword">if</span> (bottom = y &gt;= (ym = (y0 + y1) / <span class="number">2</span>)) y0 = ym; <span class="keyword">else</span> y1 = ym;</div><div class="line">    </div><div class="line">    <span class="comment">// 判断当前添加节点所处象限是否为空，对应case3</span></div><div class="line">    <span class="keyword">if</span> (parent = node, !(node = node[i = bottom &lt;&lt; <span class="number">1</span> | right])) <span class="keyword">return</span> parent[i] = leaf, tree;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// node为查询节点</span></div><div class="line">  <span class="comment">// Is the new point is exactly coincident with the existing point?</span></div><div class="line">  xp = +tree._x.call(<span class="literal">null</span>, node.data);</div><div class="line">  yp = +tree._y.call(<span class="literal">null</span>, node.data);</div><div class="line">  <span class="comment">// 特殊情况，若当前需要加入的节点与父节点完全重合，对应case4</span></div><div class="line">  <span class="keyword">if</span> (x === xp &amp;&amp; y === yp) <span class="keyword">return</span> leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;</div><div class="line"></div><div class="line">  <span class="comment">// 不停分割，直至处于不同象限，对应case2</span></div><div class="line">  <span class="comment">// Otherwise, split the leaf node until the old and new point are separated.</span></div><div class="line">  <span class="keyword">do</span> &#123;</div><div class="line">    parent = parent ? parent[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">4</span>) : tree._root = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">4</span>);</div><div class="line">    <span class="keyword">if</span> (right = x &gt;= (xm = (x0 + x1) / <span class="number">2</span>)) x0 = xm; <span class="keyword">else</span> x1 = xm;</div><div class="line">    <span class="keyword">if</span> (bottom = y &gt;= (ym = (y0 + y1) / <span class="number">2</span>)) y0 = ym; <span class="keyword">else</span> y1 = ym;</div><div class="line">  &#125; <span class="keyword">while</span> ((i = bottom &lt;&lt; <span class="number">1</span> | right) === (j = (yp &gt;= ym) &lt;&lt; <span class="number">1</span> | (xp &gt;= xm)));</div><div class="line">  <span class="keyword">return</span> parent[j] = node, parent[i] = leaf, tree;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://ol2d3d8nb.bkt.clouddn.com/24-3.png" alt="四叉树添加节点模拟"></p><p>四叉树的构建完成后，自四叉树由下而上，求所有节点的合坐标与合静电电荷量。若当前节点 $quad$ 为索引节点，其中 strength 为静电电荷量，默认值均为 -30，可由开发者自定义。</p><p>合坐标公式: $(quad.x = \frac{\sum\limits_{i=0}^{3} (quad[i].value * quad[i].x)}{\sum\limits_{i=0}^{3} (quad[i].value)}, quad.y = \frac{\sum\limits_{i=0}^{3} (quad[i].value * quad[i].y)}{\sum\limits_{i=0}^{3} (quad[i].value)})$</p><p>合电荷量公式: $\sum\limits_{i=0}^{3} (quad[i].value)$</p><p>若当前节点为真实节点，坐标即为当前真实节点坐标，静电电荷量则为真实节点及其下挂真实节点 strength 总和。</p><h3 id="斥力的优化求解"><a href="#斥力的优化求解" class="headerlink" title="斥力的优化求解"></a>斥力的优化求解</h3><p>节点间的关键就在于电荷斥力的求解。在原来的朴素算法中，需要每个节点对其他所有节点求解斥力，算法复杂度为 $O(n^2)$，而目前采用四叉树与 Barnes-Hut 近似，算法复杂度 $O(nlogn)$，其核心思想在于，当前节点 (node) 计算远处节点的斥力对速度位移影响时，可将其周围相近的点产生的相同斥力效果做整合处理，形成”质心”，而这个”周围”的大小就由四叉树的矩阵与 Barnes-Hut 近似精度 theta 所决定，theta 默认值为 $(0.9)^2$。</p><p>当前象限区域面积 $S_1$ 为 $(x_1 - x_2)^2$，当前节点 (node) 与象限合节点 (quad) 形成矩阵面积 $S_2$ 为 $(quad.x - node.x) * (quad.y - node.y)$，当 $\frac{S_1}{S_2} &lt; theta$ 时，计算当前节点与象限合节点的相互作用力，将其转化为 node 速度变化量:</p><p>根据 <strong>Velocity Verlet</strong> 算法， $v(t + \Delta t) = v(t) + \frac{f(t + \Delta t) + f(t)}{2m}\Delta t$，d3 进行了简化处理，设 $m = 1, \Delta t = 1$:</p><p>$\Delta v = v(t + \Delta t) - v(\Delta t) = \frac{f(t + \Delta t) + f(t)}{2m}\Delta t \approx f(t)$</p><p>而在 d3 源码中，$node.vx += (\frac{x * quad.value}{x^2 + y^2}) * alpha$，alpha 是阻尼衰减系数。暂时无法理解这个求解过程，按照电场力求解公式 $F = \frac{kQq}{r^2}$ 推导，再将力分解到 x 轴，与现有求解不符，已提 issue 给代码的作者，希望能得到他的解答。</p><p>具体代码如下，apply 函数第一个参数 quad 为四叉树索引节点，内有索引下属子节点的合坐标 $(quad.x, quad.y)$ 和合电荷量。其返回 true 意味着，当前节点及其子节点已完成计算，否则需要继续向下遍历节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> distanceMin2 = <span class="number">1</span>,</div><div class="line">    distanceMax2 = <span class="literal">Infinity</span>,</div><div class="line">    theta2 = <span class="number">0.81</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">apply</span>(<span class="params">quad, x1, _, x2</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!quad.value) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> x = quad.x - node.x,</div><div class="line">      y = quad.y - node.y,</div><div class="line">      w = x2 - x1,</div><div class="line">      l = x * x + y * y;</div><div class="line">      </div><div class="line">  <span class="comment">// 是否可采用 Barnes-Hut 近似</span></div><div class="line">  <span class="comment">// Apply the Barnes-Hut approximation if possible.</span></div><div class="line">  <span class="comment">// Limit forces for very close nodes; randomize direction if coincident.</span></div><div class="line">  <span class="keyword">if</span> (w * w / theta2 &lt; l) &#123;</div><div class="line">    <span class="keyword">if</span> (l &lt; distanceMax2) &#123;</div><div class="line">      <span class="keyword">if</span> (x === <span class="number">0</span>) x = jiggle(), l += x * x;</div><div class="line">      <span class="keyword">if</span> (y === <span class="number">0</span>) y = jiggle(), l += y * y;</div><div class="line">      <span class="keyword">if</span> (l &lt; distanceMin2) l = <span class="built_in">Math</span>.sqrt(distanceMin2 * l);</div><div class="line">      node.vx += x * quad.value * alpha / l;</div><div class="line">      node.vy += y * quad.value * alpha / l;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 无法采用 Barnes-Hut 近似且 quad 有节点，或 l 大于距离上限，需要继续向下遍历</span></div><div class="line">  <span class="comment">// Otherwise, process points directly.</span></div><div class="line">  </div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (quad.length || l &gt;= distanceMax2) <span class="keyword">return</span>;</div><div class="line">  </div><div class="line">  <span class="comment">// 排除自身对自身影响</span></div><div class="line">  <span class="comment">// Limit forces for very close nodes; randomize direction if coincident.</span></div><div class="line">  <span class="keyword">if</span> (quad.data !== node || quad.next) &#123;</div><div class="line">    <span class="keyword">if</span> (x === <span class="number">0</span>) x = jiggle(), l += x * x;</div><div class="line">    <span class="keyword">if</span> (y === <span class="number">0</span>) y = jiggle(), l += y * y;</div><div class="line">    <span class="keyword">if</span> (l &lt; distanceMin2) l = <span class="built_in">Math</span>.sqrt(distanceMin2 * l);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">do</span> <span class="keyword">if</span> (quad.data !== node) &#123;</div><div class="line">    w = strengths[quad.data.index] * alpha / l;</div><div class="line">    node.vx += x * w;</div><div class="line">    node.vy += y * w;</div><div class="line">  &#125; <span class="keyword">while</span> (quad = quad.next);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="节点连线的处理"><a href="#节点连线的处理" class="headerlink" title="节点连线的处理"></a>节点连线的处理</h2><p>相比节点的处理而言，节点的连线简单了许多，没有使用任何优化，先初始化连线，统计每个节点的度，求每一条边的起点 (source) 度的占比，使 bias = 起点度 / (起点度 + 终点度)。每条边的默认长度 (distance) 为30，默认弹簧劲度系数 (strength) 为 1 / min(起点度, 终点度)，这是为了减小对于度较大节点的引力，提高稳定性。</p><p>遍历所有连线，计算施加在连线两端节点的引力，最终推导出速度的变化:</p><p>$target.vx -= k * \Delta x * cos\theta * alpha * bias$</p><p>$= strengths[i] * (l - distances[i]) * \frac{x}{\sqrt{x^2 + y^2}} * alpha * bias$</p><p>target.vy、source.vx、source.vy 同理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> iterations = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">force</span>(<span class="params">alpha</span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>, n = links.length; k &lt; iterations; ++k) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, link, source, target, x, y, l, b; i &lt; n; ++i) &#123;</div><div class="line">      link = links[i], source = link.source, target = link.target;</div><div class="line">      x = target.x + target.vx - source.x - source.vx || jiggle();</div><div class="line">      y = target.y + target.vy - source.y - source.vy || jiggle();</div><div class="line">      l = <span class="built_in">Math</span>.sqrt(x * x + y * y);</div><div class="line">      l = (l - distances[i]) / l * alpha * strengths[i];</div><div class="line">      x *= l, y *= l;</div><div class="line">      target.vx -= x * (b = bias[i]);</div><div class="line">      target.vy -= y * b;</div><div class="line">      source.vx += x * (b = <span class="number">1</span> - b);</div><div class="line">      source.vy += y * b;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="布局的形成"><a href="#布局的形成" class="headerlink" title="布局的形成"></a>布局的形成</h2><p>布局的形成主要依靠不断的迭代计算，每处理一次节点与节点连线称为一步，循环往复，通过 alpha 逐渐衰减与 (fx, fy) 来进行控制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> simulation,</div><div class="line">    alpha = <span class="number">1</span>,</div><div class="line">    alphaMin = <span class="number">0.001</span>,</div><div class="line">    <span class="comment">// alpha衰减率</span></div><div class="line">    alphaDecay = <span class="number">1</span> - <span class="built_in">Math</span>.pow(alphaMin, <span class="number">1</span> / <span class="number">300</span>),</div><div class="line">    alphaTarget = <span class="number">0</span>,</div><div class="line">    <span class="comment">// 速度衰减</span></div><div class="line">    velocityDecay = <span class="number">0.6</span>,</div><div class="line">    stepper = timer(step),</div><div class="line">    <span class="comment">// tick事件与end事件</span></div><div class="line">    event = dispatch(<span class="string">"tick"</span>, <span class="string">"end"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  tick();</div><div class="line">  event.call(<span class="string">"tick"</span>, simulation);</div><div class="line">  <span class="keyword">if</span> (alpha &lt; alphaMin) &#123;</div><div class="line">    stepper.stop();</div><div class="line">    event.call(<span class="string">"end"</span>, simulation);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// alpha不断衰减</span></div><div class="line">  alpha += (alphaTarget - alpha) * alphaDecay;</div><div class="line"></div><div class="line">  <span class="comment">// 不停迭代</span></div><div class="line">  forces.each(<span class="function"><span class="keyword">function</span>(<span class="params">force</span>) </span>&#123;</div><div class="line">    force(alpha);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="comment">// 速度转化为距离改变</span></div><div class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</div><div class="line">    node = nodes[i];</div><div class="line">    <span class="keyword">if</span> (node.fx == <span class="literal">null</span>) node.x += node.vx *= velocityDecay;</div><div class="line">    <span class="comment">// 具有fx，说明当前节点被控制，不需要受到力的影响，速度置为0</span></div><div class="line">    <span class="keyword">else</span> node.x = node.fx, node.vx = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (node.fy == <span class="literal">null</span>) node.y += node.vy *= velocityDecay;</div><div class="line">    <span class="keyword">else</span> node.y = node.fy, node.vy = <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>d3-force 的实现与传统图力导引布局中的 FR 算法具有完全相同的算法思路，均将迭代分为三部分，先计算节点之间相互的排斥力，然后是计算图中有边连接的节点之间相互的吸引力，最后综合吸引力和排斥力，来得到每个节点的速度，而不是加速度。同时采用类似于模拟退火的衰减方案，使布局趋于稳定。</p><p>在力的求解方式上，d3 的实现与 FR 的求解有所不同，对于 FR 中引力和斥力的公式推导也暂时没有想明白，这是一个优化点。此外，d3 中包括节点的静电电荷量，连线弹簧的长度、劲度系数，连线引力的迭代次数目前都采用了默认值，可否进行调整，这也是一个优化点。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/d3/d3-force" target="_blank" rel="external">d3-force doc</a><br><a href="https://github.com/d3/d3-quadtree" target="_blank" rel="external">d3-quadtree doc</a><br><a href="https://en.wikipedia.org/wiki/Verlet_integration#Velocity_Verlet" target="_blank" rel="external">Velocity_Verlet wiki</a><br><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.32.1594&amp;rep=rep1&amp;type=pdf" target="_blank" rel="external">A Multilevel Algorithm for Force-Directed Graph Drawing</a><br><a href="http://www.docin.com/p-834916360.html" target="_blank" rel="external">图布局力导引算法研究与实现</a><br><a href="http://www.docin.com/p-215443388.html" target="_blank" rel="external">基于Barnes Hut算法的N-body问题模拟</a></p></div><div></div><div></div><div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/d3/" rel="tag"># d3</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2016/08/17/基于-Decorator-的组件扩展实践/" rel="next" title="基于 Decorator 的组件扩展实践"><i class="fa fa-chevron-left"></i> 基于 Decorator 的组件扩展实践</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/02/08/Recharts-With-HTML-Email/" rel="prev" title="Recharts With HTML Email">Recharts With HTML Email<i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="http://ol2d3d8nb.bkt.clouddn.com/fly.jpg" alt="淡苍"><p class="site-author-name" itemprop="name">淡苍</p><p class="site-description motion-element" itemprop="description">在寻找大神的路上让自己成为大神</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">27</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">10</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">19</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/BlackGanglion" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="http://weibo.com/BlackGanglion" target="_blank" title="微博"><i class="fa fa-fw fa-weibo"></i> 微博</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/BlackGanglion" target="_blank" title="知乎"><i class="fa fa-fw fa-globe"></i> 知乎</a></span></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#节点的处理与优化"><span class="nav-number">1.</span> <span class="nav-text">节点的处理与优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化导入节点"><span class="nav-number">1.1.</span> <span class="nav-text">初始化导入节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#建立节点四叉树"><span class="nav-number">1.2.</span> <span class="nav-text">建立节点四叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#斥力的优化求解"><span class="nav-number">1.3.</span> <span class="nav-text">斥力的优化求解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#节点连线的处理"><span class="nav-number">2.</span> <span class="nav-text">节点连线的处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#布局的形成"><span class="nav-number">3.</span> <span class="nav-text">布局的形成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number">4.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-number">5.</span> <span class="nav-text">参考资料</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2015 - <span itemprop="copyrightYear">2017</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">淡苍</span></div><div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div><div class="theme-info">主题 - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script><script>var cloudTieConfig={url:document.location.href,sourceId:"",productKey:"1731a0e2bd524856adb80de9dc9d1426",target:"cloud-tie-wrapper"}</script><script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script><script>!function(){var t=document.createElement("script"),s=window.location.protocol.split(":")[0];"https"===s?t.src="https://zz.bdstatic.com/linksubmit/push.js":t.src="http://push.zhanzhang.baidu.com/push.js";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });</script><script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>